<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> demystifying-javascript-closures-callbacks-iifes · Hexo of Tilly Vally @ GitHub</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">主页</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   博客</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li><li class="nav-list-item"><a href="https://github.com/xxxxx" target="_blank" class="nav-link">   github</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/03/23/demystifying-javascript-closures-callbacks-iifes/" class="post-title-link">demystifying-javascript-closures-callbacks-iifes</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Callback/" class="post-tag-link">Callback</a></li><li class="post-tag-item"><a href="/tags/Closure/" class="post-tag-link">Closure</a></li><li class="post-tag-item"><a href="/tags/IIFE/" class="post-tag-link">IIFE</a></li><li class="post-tag-item"><a href="/tags/JavaScript/" class="post-tag-link">JavaScript</a></li></ul><div class="post-time">星期五, 七月 15日 2016</div></div><div class="post-content"><h1 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h1><p>在JavaScript中, 一个<code>closure</code>就是一个保留了对父作用域内变量引用的函数，即使其父函数已经返回。</p>
<p>这特别意味着任何函数都可以被当作闭包，因为函数可以引用或访问：</p>
<ul>
<li>其自身作用域内的任何变量和参数</li>
<li>其外部（父或包含）函数作用域内的变量和参数</li>
<li>全局域内的变量</li>
</ul>
<p>为了更好的理解闭包的概念，可将上面的定义分解为三个容易理解的要点：</p>
<p><strong>Point 1:</strong> <em>可以引用在当前函数外部定义的变量</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLocation</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> country = <span class="string">"France"</span>; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printLocation</span>(<span class="params"></span>) </span>&#123;       </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"You are in "</span> + city + <span class="string">", "</span> + country);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printLocation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setLocation (<span class="string">"Paris"</span>);  <span class="comment">// output: You are in Paris, France</span></span><br></pre></td></tr></table></figure></p>
<p>在这样一段代码中，<code>printLocation()</code>函数引用了变量<code>country</code>和包含函数（父函数）<code>setLocation()</code>的参数<code>city</code>. </p>
<p><strong>Point 2:</strong> <em>内部函数可以引用在外部函数中定义的变量，即使外部函数已经返回</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setLocation</span>(<span class="params">city</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> country = <span class="string">"France"</span>; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printLocation</span>(<span class="params"></span>) </span>&#123;       </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"You are in "</span> + city + <span class="string">", "</span> + country);  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> printLocation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentLocation = setLocation (<span class="string">"Paris"</span>);   </span><br><span class="line"></span><br><span class="line">currentLocation();   <span class="comment">// output: You are in Paris, France</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子与第一个例子几乎完全一样，除了这一次<code>printLocation()</code>在外部函数<code>setLocation()</code>中被返回，而不是像之前那样被立即调用。因此，<code>currentLocation</code>的值是内部的<code>printLocation()</code>函数.</p>
<p>如果执行<code>alert(currentLocation);</code> 输出结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLocation</span> (<span class="params"></span>) </span>&#123;       </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"You are in "</span> + city + <span class="string">", "</span> + country);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>printLocation()</code> 在其词法作用域（静态作用域）外部执行。此时，<code>setLocation()</code>似乎已经消失了，但<code>printLocation()</code>仍然能访问并记住它的变量<code>(country)</code>和参数<code>(city)</code>.</p>
<p>闭包(内部函数)能记住它的包围作用域（外部函数），即使闭包在其词法作用域外部执行。因此，可以在后续的任何时间点调用闭包。</p>
<p><strong>Point 3:</strong> <em>内部函数存储对外部函数的变量的引用，而不是变量的值</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cityLocation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> city = <span class="string">"Paris"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(city); &#125;,  </span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newCity</span>) </span>&#123; city = newCity; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myLocation = cityLocation();</span><br><span class="line"></span><br><span class="line">myLocation.get();           <span class="comment">// output: Paris</span></span><br><span class="line">myLocation.set(<span class="string">'Sydney'</span>);</span><br><span class="line">myLocation.get();           <span class="comment">// output: Sydney</span></span><br></pre></td></tr></table></figure></p>
<p>这里的<code>cityLocation()</code>返回一个对象，这个对象有两个闭包：<code>get()</code>和<code>set()</code>，都对外部变量<code>city</code>进行了引用. <code>get()</code>获取<code>city</code>的当前值, 而<code>set()</code>更新这个值。当第二次调用<code>myLocation.get()</code>时，输出<code>city</code>更新后（当前）的值“Sydney”，而不是默认的“Paris”.</p>
<p>因此，闭包可以读取并更新它们存储的变量，更新的结果对任何访问变量的闭包可见。这就是说，闭包存储的是外部变量的引用，而不是变量值的复本。这是需要牢记的一点，不清楚这一点会引起难以查觉的逻辑错误。</p>
<p>闭包的一个有趣特征是闭包中的变量自动被隐藏。闭包在其封闭的变量中存储数据，不能直接访问。唯一变更这些变量的方法是通过非直接方式访问变量。例如，在上面那个最后的例子里，通过使用闭包<code>get()</code>和<code>set()</code>转弯抹角地对变量<code>city</code>进行修改。</p>
<p>这种行为上的特点可被用来在对象中存储私有数据。与把数据作为对象属性相反，可将数据存储为构造函数中的变量，使用闭包作为方法引用这些变量。</p>
<h1 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h1><p>在JavaScript中, 函数是头等对象. 后果之一是，函数可被当作实参传递给其它函数，也可以被其它函数返回。</p>
<p>一个函数被称为高阶函数，如果它以其它函数为实参，或者将其它函数作为结果返回。被作为实参传递的函数称为回调函数。</p>
<p>回调函数有许多常见应用场景，例如浏览器的<code>window</code>对象的<code>setTimeout()</code>和<code>setInterval()</code>方法，接收并执行回调：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(message);</span><br><span class="line">  &#125;, <span class="number">3000</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showMessage(<span class="string">'Function called 3 seconds ago'</span>);</span><br></pre></td></tr></table></figure></p>
<p>另一个例子是对页面上的元素添加一个事件监听器。实际上就是提供了当事件发生时被调用的一个回调函数指针.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line"></span><br><span class="line">&amp;lt;button id='btn'&amp;gt;Click me&amp;lt;/button&amp;gt;</span><br><span class="line"></span><br><span class="line">// JavaScript</span><br><span class="line"></span><br><span class="line">function showMessage()&#123;</span><br><span class="line">  alert('Woohoo!');</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var el = document.getElementById("btn");</span><br><span class="line">el.addEventListener("click", showMessage);</span><br></pre></td></tr></table></figure></p>
<p>理解高阶函数和回调函数的最好方法是自己写一个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullName</span>(<span class="params">firstName, lastName, callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + firstName + <span class="string">" "</span> + lastName);</span><br><span class="line">  callback(lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">ln</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome Mr. '</span> + ln);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fullName(<span class="string">"Jackie"</span>, <span class="string">"Chan"</span>, greeting);</span><br></pre></td></tr></table></figure></p>
<p><code>fullName()</code>函数有三个实参 - 最后一个是回调函数. 在<code>console.log()</code>之后，对这个传入的实参回调函数’callback()’进行了触发，也就是在<code>fullName()</code>之后定义的<code>greeting()</code>函数。最后，对<code>fullName()</code>进行调用, <code>greeting()</code>作为变量传递（没有括号），因为并不想让它立即执行，而只是想为<code>fullName()</code>指明后面要调用的是它。</p>
<p>传递回调函数的定义，而不是函数调用。这样可以防止回调函数立即执行，这种方式并不是回调函数的设计初衷。 当回调函数的定义被传递后，可以在任何时间和包含函数任何一点执行。而且，回调函数的行为看起来好像它是在高阶函数内部, 因此它实际上是闭包：它可以访问包含函数的变量和参数，甚至全局变量。</p>
<p>回调可以是前例中那样的已存在的函数，也可以是下面这个例子中这样的匿名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullName</span>(<span class="params">firstName, lastName, callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + firstName + <span class="string">" "</span> + lastName);</span><br><span class="line">  callback(lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullName(<span class="string">"Jackie"</span>, <span class="string">"Chan"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ln</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'Welcome Mr. '</span> + ln);&#125;);</span><br></pre></td></tr></table></figure></p>
<p>回调函数在JavaScript库中的使用很普遍，以提供通用性和可重用度。回调函数可很容易地定制和（或）扩展库方法. 而且，代码易于维护，更精炼，可读性更强。当需要把不必要的重复代码变换为更抽象和更通用的函数时，回调函数就能发挥作用。</p>
<p>例如，假定需要两个函数：一个打印已出版文章的信息，另一个打印已发送消息的信息。当创建这两个函数时会发现，其中有重复的逻辑，在不同的地方有同样的代码是没必要的，解决方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">item, author, callback</span>)</span>&#123;   <span class="comment">// Generic function with common data</span></span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">  callback(author, date);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messages</span>(<span class="params">author, time</span>)</span>&#123;   <span class="comment">// Callback function with specific data</span></span><br><span class="line">  <span class="keyword">var</span> sendTime = time.toLocaleTimeString();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Sent from "</span> + author + <span class="string">" at "</span> + sendTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">articles</span>(<span class="params">author, date</span>)</span>&#123;   <span class="comment">// Callback function with specific data</span></span><br><span class="line">  <span class="keyword">var</span> pubDate = date.toDateString();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Written by "</span> + author);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Published "</span> + pubDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">publish(<span class="string">"How are you?"</span>, <span class="string">"Monique"</span>, messages);</span><br><span class="line"></span><br><span class="line">publish(<span class="string">"10 Tips for JavaScript Developers"</span>, <span class="string">"Jane Doe"</span>, articles);</span><br></pre></td></tr></table></figure></p>
<p>重复的代码模式<code>console.log(item) and var date = new Date()</code>被抽取到一个独立和通用的函数<code>publish()</code>, 只在其它函数（即回调函数）中留下特定的数据. 这样，只用一个同样的函数就可以打印所有类似的东西:消息、文章、书箱、杂志等等。你只需要做一件事-为每种类型创建一个特定的回调函数，把它作为实参传递给<code>publish()</code>函数。</p>
<h1 id="Immediately-Invoked_Function_Expressions__28IIFEs_29"><a href="#Immediately-Invoked_Function_Expressions__28IIFEs_29" class="headerlink" title="Immediately-Invoked Function Expressions (IIFEs)"></a>Immediately-Invoked Function Expressions (IIFEs)</h1><p><strong>Immediately-invoked function expression</strong>, <strong>IIFE</strong> (发音为“iffy”), 是一个在创建后被立即执行的函数表达式（命名或匿名）。</p>
<p>IIFEs有两种有细微差别语法形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// variant 1</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Woohoo!'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// variant 2</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Woohoo!'</span>);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>把一个常规函数变为IIFE，需要以下两步：</p>
<ol>
<li>将整个函数包围在圆括号中。如其名称，IIFE必须是一个函数表达式，而不是一个函数定义。圆括号的目的是把函数定义变为表达式。因为在JavaScript中, 所有在圆括号内的代码被当作一个表达式。</li>
<li>在变化1中，需要在末尾添加一对圆括号，或者在变化2中，紧跟花括号添加一对圆括号，以让函数立即执行。</li>
</ol>
<p>还有三点要记住：</p>
<p>首先，如果把函数赋值给一个变量，不需要用圆括号包围这个函数，赋值操作本身就是一个表达式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayWoohoo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Woohoo!'</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>其次，IIFE最后需要一个分号.</p>
<p>第三点，可以给IIFE传递实参（因为它本身毕竟是一个函数）:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">name, profession</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"My name is "</span> + name + <span class="string">". I'm an "</span> + profession + <span class="string">"."</span>);</span><br><span class="line">&#125;)(<span class="string">"Jackie Chan"</span>, <span class="string">"actor"</span>);   <span class="comment">// output: My name is Jackie Chan. I'm an actor.</span></span><br></pre></td></tr></table></figure></p>
<p>把全局对象作为一个实参传递给IIFE是一种常见使用方式，这样在函数内部就可以访问全局对象，而不需要使用<code>window</code>对象, 从而使代码独立于浏览器环境。下面的例子创建一个全局变量以引用全局对象，与平台无关:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// access the global object via 'global'</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面的代码既可以在浏览器（全局对象为<code>window</code>）中运行,也可以在Node.js（用特殊变量<code>global</code>引用全局对象）.</p>
<p>IIFE的好处之一是，不用担心临时变量对全局空间的污染. 所有在IIFE内定义的变量都是局部变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> currentTime = today.toLocaleTimeString();</span><br><span class="line">  <span class="built_in">console</span>.log(currentTime);   <span class="comment">// output: the current local time (e.g. 7:08:52 PM)</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(currentTime);   <span class="comment">// output: undefined</span></span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，第一个<code>console.log()</code>正常工作，第二个会失败，因为变量<code>today</code>和<code>currentTime</code>是局部的。</p>
<p>我们知道，闭包保留了对外部变量的引用，因此，只返回最近最新的值。那么，下面这个例子的输出是什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFruits</span>(<span class="params">fruits</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( fruits[i] );</span><br><span class="line">    &#125;, i * <span class="number">1000</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFruits([<span class="string">"Lemon"</span>, <span class="string">"Orange"</span>, <span class="string">"Mango"</span>, <span class="string">"Banana"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>看起来像是间隔1秒顺序输出4种水果的名字。但实际上，是4次 “undefined”.</p>
<p>关键的地方在于<code>i</code>的值, 在<code>console.log()</code>中它在每次循环中都等于4，而<code>fruits</code>数组没有第5个元素，因此输出为“undefined”.循环结束的条件是<code>i &lt; fruits.length</code>返回<code>false</code>. 因此，循环结束时，<code>i</code>的值是4. 当定时器触发时，<code>i</code>的引用内存储的值为4，<code>console.log()</code>这个闭包函数根据这个引用取得最后，也就是最新的值4.</p>
<p>要修订这个问题，需要提供一个新的作用域：为每轮循环创建函数，以获取变量<code>i</code>的当前状态。 把<code>setTimeout()</code>包围在IIFE中，并在IIFE中定义一个私有变量，以保存当前<code>i</code>值的复本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFruits</span>(<span class="params">fruits</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; fruits.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> current = i;                    <span class="comment">// define new variable that will hold the current value of "i"</span></span><br><span class="line">      setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( fruits[current] );   <span class="comment">// this time the value of "current" will be different for each iteration</span></span><br><span class="line">      &#125;, current * <span class="number">1000</span> );</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFruits([<span class="string">"Lemon"</span>, <span class="string">"Orange"</span>, <span class="string">"Mango"</span>, <span class="string">"Banana"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>下面是另一种实现形式，效果一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFruits</span>(<span class="params">fruits</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &amp;lt; fruits.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">current</span>)</span>&#123;</span><br><span class="line">      setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( fruits[current] );</span><br><span class="line">      &#125;, current * <span class="number">1000</span> );</span><br><span class="line">    &#125;)( i );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFruits([<span class="string">"Lemon"</span>, <span class="string">"Orange"</span>, <span class="string">"Mango"</span>, <span class="string">"Banana"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>IIFE常用于创建域以封闭模块。在模块内部，是自包含的私有域，免于不经意的篡改。这种技术称为模块模式，是使用闭包管理作用域的强大例子，在现代JavaScript库中(如jQuery、Underscore）频繁使用。</p>
</div></article><div class="pagination"><a href="/2016/03/25/AngularJS/" class="pagination-prev">PREV</a><a href="/2016/03/01/Browserify/" class="pagination-next">NEXT</a></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browserify/">Browserify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Callback/">Callback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Closure/">Closure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Table Layout in CSS/">Table Layout in CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Exam Analysis/">Exam Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/JQuery EasyUI Sourece Code Analysis/">JQuery EasyUI Sourece Code Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/AngularJS/">Angular</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/demystifying-javascript-closures-callbacks-iifes/">demystifying-javascript-closures-callbacks-iifes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Browserify/">Browserify</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/strict-mode/">strict mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/Try{} and Catch{}/">Try{} and Catch{}</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2016 <a href="/">Tilly Vally</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>