<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javascript Patterns · Hexo of Tilly Vally @ GitHub</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">主页</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   博客</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li><li class="nav-list-item"><a href="https://github.com/xxxxx" target="_blank" class="nav-link">   github</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/02/24/Patterns/" class="post-title-link">javascript Patterns</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/JavaScript/" class="post-tag-link">JavaScript</a></li><li class="post-tag-item"><a href="/tags/Pattern/" class="post-tag-link">Pattern</a></li></ul><div class="post-time">星期五, 七月 15日 2016</div></div><div class="post-content"><h1 id="JavaScript_Patterns"><a href="#JavaScript_Patterns" class="headerlink" title="JavaScript Patterns"></a>JavaScript Patterns</h1><p>当开始开发大的系统时，会遇到一些重复问题，可以用标准的方法来做。 模式可用来解决这类已知和可识别的问题。模式是解决常见问题的 最好实践、可用抽象或模板。编写可维护代码很难，写出模块化正确可维护代码的关键是：理解重复场景，用通用模板实现优化的解决方案。在设计模式中领域里，最重要的的书籍是Erich Gamma，Richard Helm, Ralph Johnson, and John Vlissides（著名的the Gang of Four  - GOF)所著的出版于1995年的<strong>Design Patterns: Elements Of Reusable Object-Oriented Software</strong>. 在这本开创性的著作中，正式命名了各种类型的模式，阐述了今天所见的大部分常见模式的实现细节。理解模式的重要性是非常重要的：</p>
<ul>
<li>Patterns提供了常见问题的已证明解决方案：Patterns提供了特定问题的优化模板。 这些模式背后有大量经验丰富的工程师支持，并经过实效检测。</li>
<li>Patterns被设计为可重用：它们足够通用，以适应问题的不同变化。</li>
<li>Patterns定义了词汇表：Patterns是精确定义的结构，因此提供了关于解决方案的通用词汇表。这对于大型团队的交流非常便利。<h2 id="u8BBE_u8BA1_u6A21_u5F0F"><a href="#u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="设计模式"></a>设计模式</h2>在一般的软件开发周期里，存在劣质代码引入的可能性, 主要集中于代码临近发布时和交由其他团队维护时。如果这样的劣质设计结构记录为anti-patterns, 它们可以为开发人员提供指导，以确认避免哪些陷井和如何不继续劣质设计模式。大多数语言都有其自己的antipatterns集合.基于其解决的问题，设计模式被GOF分为几个大类：</li>
<li><strong>Creational design patterns</strong>:这类处理对象创建的不同机制。虽然大多数语言提供了基本的对象创建方法，但这类模式寻求优化的或可控性更强的对象创建机制。</li>
<li><strong>Structural design patterns</strong>: 这类模式与对象的组成成分及其之间关系有关。理念是当系统中的某些事情发生变化时，对全部的对象关系的影响最小。</li>
<li><strong>Behavioral design patterns</strong>: 这类模式专注于对象间的依赖与通信。</li>
</ul>
<p>下表是常见模式分类表：</p>
<ul>
<li>Creational patterns:<ul>
<li>Factory method</li>
<li>Abstract factory</li>
<li>Builder</li>
<li>Prototype</li>
<li>Singleton</li>
</ul>
</li>
<li>Structural patterns:<ul>
<li>Adapter</li>
<li>Bridge</li>
<li>Composite</li>
<li>Decorator</li>
<li>Façade</li>
<li>Flyweight</li>
<li>Proxy</li>
</ul>
</li>
<li>Behavioral patterns<ul>
<li>Interpreter</li>
<li>Template method</li>
<li>Chain of responsibility</li>
<li>Command</li>
<li>Iterator</li>
<li>Mediator</li>
<li>Memento</li>
<li>Observer</li>
<li>State</li>
<li>Strategy</li>
<li>Visitor</li>
</ul>
</li>
</ul>
<h2 id="The_namespace_pattern"><a href="#The_namespace_pattern" class="headerlink" title="The namespace pattern"></a>The namespace pattern</h2><p>过度使用全局域在JavaScript几乎是禁忌。命名空间可以减少全局域的数量，避免名称冲突或过度使用名称前缀。<br>命名空间就是为应用或库创建一个全局对象，把所有其他对象和方法添加到这个全局对象，而不是在一个全局域内使用它们。 JavaScript没有明确的命名空间语法，但可以很容易地创建命名空间：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BMW</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> engines = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> features = &#123;</span><br><span class="line">	seats: <span class="number">6</span>,</span><br><span class="line">	airbags:<span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所有的东西都全局域内创建，这样是违反模式的，不是一个好做法。需要重构代码，创建一个单一对象，将所有函数和对象作为这个对象的一部分:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single global object</span></span><br><span class="line"><span class="keyword">var</span> CARFACTORY = CARFACTORY || &#123;&#125;;</span><br><span class="line">CARFACTORY.Car = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">CARFACTORY.BMW = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">CARFACTORY.engines = <span class="number">1</span>;</span><br><span class="line">CARFACTORY.features = &#123;</span><br><span class="line">	seats: <span class="number">6</span>,</span><br><span class="line">	airbags:<span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>全局命名空间对象的名称一般是全部大写。对于限定全局域数量，增加命名空间来说，虽然这样看起来不错，但每个变量和函数前都加前缀显得有一点啰唆. 而且，单一全局实例意味着代码的任何部分都可以修改全局实例，同时其他部分的功能又可以获取更新的状态。这会引起非常麻烦的副作用。</p>
<p>上例中的<code>var CARFACTORY = CARFACTORY || {};</code>这一行代码显得有点奇怪。当开发大型软件时，不能假定某个命名空间是首次创建（或增加一个属性给这个命名空间）. 很有可能该命名空间已经有了。为确保该命名空间在不存在的条件下被创建， 要加入short-circuit ||操作符.</p>
<h2 id="The_module_pattern"><a href="#The_module_pattern" class="headerlink" title="The module pattern"></a>The module pattern</h2><p>模块化有助于保持代码的独立性和组织性。模块化将大程序分离为更小的代码段，并为其分配命名空间。这样的模块具有可重用性。精巧的模块接口设计使代码易于使用和扩展。<br>JavaScript函数和对象的灵活性很容易创建健壮的模块. 函数域可以使命名空间是模块内部的，对象可用于存储导出值的集合。</p>
<p>Object literals可以创建如下的name-value对.下面的例子创建了一个object literal并定义了key-value对，以创建属性和函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicServerConfig = &#123;</span><br><span class="line">	environment: <span class="string">"production"</span>,</span><br><span class="line">	startupParams: &#123;</span><br><span class="line">		cacheTimeout: <span class="number">30</span>,</span><br><span class="line">		locale: <span class="string">"en_US"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">"Initializing the server"</span> );</span><br><span class="line">	&#125;,</span><br><span class="line">	updateStartup: <span class="function"><span class="keyword">function</span>(<span class="params"> params </span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.startupParams = params;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.startupParams.cacheTimeout );</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.startupParams.locale );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">basicServerConfig.init(); <span class="comment">//"Initializing the server"</span></span><br><span class="line">basicServerConfig.updateStartup(&#123;cacheTimeout:<span class="number">60</span>, locale:<span class="string">"en_UK"</span>&#125;); <span class="comment">//60,en_UK</span></span><br></pre></td></tr></table></figure></p>
<p>模块化模仿类的概念，包含公开/私有函数和变量，并限定它们的作用域为非全局的，防止命名冲突。另一个优点是，只暴露一个公开API.其它的内部实现在模块的闭包中是私有的。</p>
<p>与其它OO语言不同，JavaScript没有明确的access modifiers，因此没有privacy概念，也就是没有私有和公开变量的概念。在JavaScript中, 函数域用于强制实现这一概念。模块模式使用闭包以限定变量和函数只能在模块中被访问；但在返回对象中定义的变量和函数是公开的。</p>
<p>现在，把前面的例子变为模块-使用IIFE并返回模块的接口，即就是函数<strong>init</strong>和<strong>updateStartup</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> basicServerConfig = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> environment= <span class="string">"production"</span>;</span><br><span class="line">	startupParams= &#123;</span><br><span class="line">		cacheTimeout: <span class="number">30</span>,</span><br><span class="line">		locale: <span class="string">"en_US"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="string">"Initializing the server"</span> );</span><br><span class="line">		&#125;,</span><br><span class="line">		updateStartup: <span class="function"><span class="keyword">function</span>(<span class="params"> params </span>) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.startupParams = params;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="keyword">this</span>.startupParams.cacheTimeout );</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="keyword">this</span>.startupParams.locale );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">basicServerConfig.init(); <span class="comment">//"Initializing the server"</span></span><br><span class="line">basicServerConfig.updateStartup(&#123;cacheTimeout:<span class="number">60</span>, locale:<span class="string">"en_UK"</span>&#125;); <span class="comment">//60,en_UK</span></span><br></pre></td></tr></table></figure></p>
<p><strong>basicServerConfig</strong>是全局域中的一个模块。为确保模块不污染全局环境，需要创建模块的命名空间。 而且模块的重用性也需要保证，因此要避免命名冲突。对于<strong>basicServerConfig</strong>模块，下面的代码演示了如何创建命名空间：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single global object</span></span><br><span class="line"><span class="keyword">var</span> SERVER = SERVER||&#123;&#125;;</span><br><span class="line">SERVER.basicServerConfig = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	Var environment= <span class="string">"production"</span>;</span><br><span class="line">	startupParams= &#123;</span><br><span class="line">		cacheTimeout: <span class="number">30</span>,</span><br><span class="line">		locale: <span class="string">"en_US"</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="string">"Initializing the server"</span> );</span><br><span class="line">		&#125;,</span><br><span class="line">		updateStartup: <span class="function"><span class="keyword">function</span>(<span class="params"> params </span>) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.startupParams = params;</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="keyword">this</span>.startupParams.cacheTimeout );</span><br><span class="line">			<span class="built_in">console</span>.log( <span class="keyword">this</span>.startupParams.locale );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">SERVER.basicServerConfig.init(); <span class="comment">//"Initializing the server"</span></span><br><span class="line">SERVER.basicServerConfig.updateStartup(&#123;cacheTimeout:<span class="number">60</span>, locale:<span class="string">"en_UK"</span>&#125;);<span class="comment">//60, en_UK</span></span><br></pre></td></tr></table></figure></p>
<p>将模块与命名空间结合使用一般来说是好的方法，但并不是强制要求模块必须与命名空间关联。.</p>
<p>一种模块模式的变种可以克服原有模块模式的一些缺点。这种改进的变化模块模式，通常被称为<strong>revealing module pattern</strong> (<strong>RMP)</strong>.  <strong>RMP</strong> 由  <em>Christian Heilmann</em>首先推广. 他不喜欢在从一个函数中调用另一个公开函数或访问一个公开变量时必须用模块名称。另一个小问题是，在返回公开接口时必须使用<strong>object literal notation</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> modulePattern = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> privateOne = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'privateFn called'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		publicTwo: <span class="number">2</span>,</span><br><span class="line">		publicFn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			modulePattern.publicFnTwo();</span><br><span class="line">		&#125;,</span><br><span class="line">		publicFnTwo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			privateFn();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;();</span><br><span class="line">modulePattern.publicFn(); <span class="string">"privateFn called"</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码需要通过<strong>modulePattern</strong>的<strong>publicFn()</strong>调用<strong>publicFnTwo()</strong> . 此外，公开接口以<strong>object literal</strong>的方式返回. 在<strong>RMP</strong>后的主要概念是在私有域中定义所有成员，返回一个带有指针的匿名对象，这些指针指向需要被公开的私有函数。下面是将前例代码转换为<strong>RMP</strong>的例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> revealingExample = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> privateOne = <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">privateFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'privateFn called'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> publicTwo = <span class="number">2</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">publicFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		publicFnTwo();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">publicFnTwo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		privateFn();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getCurrentState</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// reveal private variables by assigning public pointers</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		setup:publicFn,</span><br><span class="line">		count:publicTwo,</span><br><span class="line">		increaseCount:publicFnTwo,</span><br><span class="line">		current:getCurrentState()</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log(revealingExample.current); <span class="comment">// 2</span></span><br><span class="line">revealingExample.setup(); <span class="comment">//privateFn called</span></span><br></pre></td></tr></table></figure></p>
<p>这种方式看起来更简洁，相比经典模式应作为首选模式。</p>
<p>目前有两种主要方法创建模块。一种被称为<strong>CommonJS modules</strong>，更适用于服务端JavaScript环境，如<strong>Node.js</strong>。一个<strong>CommonJS</strong>模块包含一个<strong>require()</strong>函数以接收模块名称并返回模块接口。<strong>CommonJS</strong>模块有两部分构成：首先是模块需暴露的变量和函数列表，当将一个变量或函数分配给变量<strong>module.exports</strong>时, 它会暴露给模块外部。其次是和模块用于导入其他模块输出的<strong>require()</strong>函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add a dependency module</span></span><br><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">length, chars</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> randomBytes = crypto.randomBytes(length);</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="comment">//Export this module to be available for other modules</span></span><br><span class="line"><span class="built_in">module</span>.exports=randomString;</span><br></pre></td></tr></table></figure></p>
<p><strong>CommonJS</strong>模块在服务端有<strong>Node.js</strong>支持，在浏览器有<strong>curl.js</strong>支持.</p>
<p>另一类风格的JavaScript模块被称为<strong>Asynchronous Module Definition (AMD)</strong>. <strong>AMD</strong>使用<code>define</code>函数定义模块。这个函数以模块名称和一个函数作为参数。当模块加载后，<strong>define</strong>函数以模块的接口为实参执行函数。<strong>AMD</strong>的目标在于异步加载模块及其依赖。<strong>define</strong>函数用于以下面的签名样式定义命名或未命名的模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">	module_id <span class="comment">/*optional*/</span>,</span><br><span class="line">	[dependencies] <span class="comment">/*optional*/</span>,</span><br><span class="line">	definition <span class="function"><span class="keyword">function</span> /*<span class="title">function</span> <span class="title">for</span> <span class="title">instantiating</span> <span class="title">the</span> <span class="title">module</span> <span class="title">or</span> <span class="title">object</span>*/</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure></p>
<p>没有依赖关系的模块也可以简写为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">&#123;</span><br><span class="line">	add: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>下面代码演示了依赖两个其他模块的一个模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">define( <span class="string">"math"</span>,</span><br><span class="line">	<span class="comment">//dependency on these two modules</span></span><br><span class="line">	[<span class="string">"sum"</span>, <span class="string">"multiply"</span>],</span><br><span class="line">	<span class="comment">// module definition function</span></span><br><span class="line">	<span class="comment">// dependencies (foo and bar) are mapped to function parameters</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> (<span class="params"> sum, multiply </span>) </span>&#123;</span><br><span class="line">		<span class="comment">// return a value that defines the module export</span></span><br><span class="line">		<span class="comment">// (that is, the functionality we want to expose for consumption)</span></span><br><span class="line">		<span class="comment">// create your module here</span></span><br><span class="line">		<span class="keyword">var</span> math = &#123;</span><br><span class="line">			demo : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(sum.calculate(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">				<span class="built_in">console</span>.log(multiply.calculate(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">return</span> math;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>require</strong>模块的使用方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"math"</span>,<span class="string">"draw"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"> math,draw </span>) </span>&#123;</span><br><span class="line">	draw<span class="number">.2</span>DRender(math.pi);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>RequireJS</strong> (<a href="http://requirejs.org/docs/whyamd.html" target="_blank" rel="external">http://requirejs.org/docs/whyamd.html</a>) 是实现了AMD的模块loader之一。</p>
<h2 id="ES6_modules"><a href="#ES6_modules" class="headerlink" title="ES6 modules"></a>ES6 modules</h2><p>两种独立的模块系统和不同的module loaders有点难以掌握。ES6试图解决这一问题，模块标准化建议想保留<strong>CommonJS</strong>和<strong>AMD</strong>模块模式的各自优点。ES6 modules的语法与<strong>CommonJS</strong>相似，并且支持异步加载和可配置的模块加载：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//json_processor.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getSiteContent</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> processJSON(url);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; getSiteContent &#125; <span class="keyword">from</span> <span class="string">"json_processor.js"</span>;</span><br><span class="line">content=getSiteContent(<span class="string">"http://google.com/"</span>);</span><br></pre></td></tr></table></figure></p>
<p>ES6 export以<strong>CommonJS</strong>类似的方式输出变量和函数。在导入时，使用<code>import</code>关键字定义引入的依赖模块。</p>
<h2 id="The_factory_pattern"><a href="#The_factory_pattern" class="headerlink" title="The factory pattern"></a>The factory pattern</h2><p>工厂模式也是一种常见的对象创建模式。它不需要constructors，而是提供一个接口以创建对象。根据传递给工厂的类型，工厂创建对应的对象。常见的实现方式是使用一个类，或者类的静态方法。这个类或方法的目的是：</p>
<ul>
<li>抽象出相似对象创建过程的重复操作</li>
<li>工厂的客户可在不知道对象创建内部过程的情况下创建对象<br>举例来说：</li>
<li>一个constructor, CarFactory()</li>
<li><strong>CarFactory</strong>的一个静态方法<strong>make()</strong>知道如何创建car类型的对象。</li>
<li>特定的car类型，如CarFactory.SUV, CarFactory.Sedan等等</li>
</ul>
<p>如果想要以如下方式使用<strong>CarFactory</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> golf = CarFactory.make(<span class="string">'Compact'</span>);</span><br><span class="line"><span class="keyword">var</span> vento = CarFactory.make(<span class="string">'Sedan'</span>);</span><br><span class="line"><span class="keyword">var</span> touareg = CarFactory.make(<span class="string">'SUV'</span>);</span><br></pre></td></tr></table></figure></p>
<p>那么下面的实现方式是标准方式.：从编程角度讲，通过构造函数来创建特定类型的对象-<code>CarFactory[const].prototype = new CarFactory()</code>.这里将对象类型映射到了对应的构造函数。这种模式的实现有不同的变化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Factory Constructor</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarFactory</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">CarFactory.prototype.info = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"This car has "</span>+<span class="keyword">this</span>.doors+<span class="string">" doors and a "</span>+<span class="keyword">this</span>.engine_capacity+<span class="string">" liter engine"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// the static factory method</span></span><br><span class="line">CarFactory.make = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> constr <span class="number">0</span>= type;</span><br><span class="line">	<span class="keyword">var</span> car;</span><br><span class="line">	CarFactory[constr].prototype = <span class="keyword">new</span> CarFactory();</span><br><span class="line">	<span class="comment">// create a new instance</span></span><br><span class="line">	car = <span class="keyword">new</span> CarFactory[constr]();</span><br><span class="line">	<span class="keyword">return</span> car;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CarFactory.Compact = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.doors = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">this</span>.engine_capacity = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CarFactory.Sedan = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.doors = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">this</span>.engine_capacity = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">CarFactory.SUV = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.doors = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">this</span>.engine_capacity = <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> golf = CarFactory.make(<span class="string">'Compact'</span>);</span><br><span class="line"><span class="keyword">var</span> vento = CarFactory.make(<span class="string">'Sedan'</span>);</span><br><span class="line"><span class="keyword">var</span> touareg = CarFactory.make(<span class="string">'SUV'</span>);</span><br><span class="line">golf.info(); <span class="comment">//"This car has 4 doors and a 2 liter engine"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="The_mixin_pattern"><a href="#The_mixin_pattern" class="headerlink" title="The mixin pattern"></a>The mixin pattern</h2><p>多态可以显著减少代码中重复函数，有利于提高函数的可重用性。可将共享功能移植为多态，以减少重复行为，专注于实现差异化功能点。考虑这样一个场景，创建一个可被任何实例对象调用的定制logger。这个logger可以扩展为多态方式使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Implement BasicServer that does the bare minimum</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'underscore'</span>);</span><br><span class="line"><span class="comment">//Shared functionality encapsulated into a CustomLogger</span></span><br><span class="line"><span class="keyword">var</span> logger = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> CustomLogger = &#123;</span><br><span class="line">		log: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(message);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> CustomLogger;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//An object that will need the custom logger to log system specific logs</span></span><br><span class="line"><span class="keyword">var</span> Server = (<span class="function"><span class="keyword">function</span> (<span class="params">Logger</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> CustomServer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.log(<span class="string">"Initializing Server…"</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// This copies/extends the members of the 'CustomLogger' into 'CustomServer'</span></span><br><span class="line">	_.extend(CustomServer.prototype, Logger);</span><br><span class="line">	<span class="keyword">return</span> CustomServer;</span><br><span class="line">&#125;(logger));</span><br><span class="line">(<span class="keyword">new</span> Server()).init(); <span class="comment">//Initializing Server…</span></span><br></pre></td></tr></table></figure></p>
<p><code>_.extend</code>来自于<strong>Underscore.js</strong>, 用于把源<strong>(Logger)</strong>的所有属性复制到目的<strong>(CustomServer.prototype)</strong>. 在上面的例代码中，创建了一个共享对象<strong>CustomLogger</strong>, 其功能被所有对象实例共享。.这样一个对象就是<strong>CustomServer</strong>—在它的<strong>init()</strong>方法中，调用了这个定制logger的<strong>log()</strong>方法。<strong>CustomServer</strong>可以调用<strong>log()</strong>方法，是因为<strong>CustomLogger</strong>是通过Underscore的 <strong>extend()</strong>扩展而来的.可以动态地增加多态的功能给一个消费者对象。多态与继承是有区别的，这一点很重要。当多个对象和类层级共享功能时使用多态。如果在单一类层级里共享功能，则使用继承。在原型继承中，当继承一个原型时，对原型的任何改变会影响到所有的继承。如果不需要这样的效果，应该使用多态。</p>
<h2 id="The_decorator_pattern"><a href="#The_decorator_pattern" class="headerlink" title="The decorator pattern"></a>The decorator pattern</h2><p>装饰模式背后的概念是从一个只有基本功能的简单对象开始设计。随着设计的演进，使用已有的修饰符增强这个简单对象。在OO特别是Java的世界里，这种方式很常见。下面是一个具有简单服务器功能的BasicServer例子. 这些基本功能可被修饰后用于特定目的。设计的服务器用于PHP和Node.js，以两个端口提供服务。对基本服务器增加不同的功能进行修饰：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phpServer = <span class="keyword">new</span> BasicServer();</span><br><span class="line">phpServer = phpServer.decorate(<span class="string">'reverseProxy'</span>);</span><br><span class="line">phpServer = phpServer.decorate(<span class="string">'servePHP'</span>);</span><br><span class="line">phpServer = phpServer.decorate(<span class="string">'80'</span>);</span><br><span class="line">phpServer = phpServer.decorate(<span class="string">'serveStaticAssets'</span>);</span><br><span class="line">phpServer.init();</span><br></pre></td></tr></table></figure></p>
<p>Node.js版本的服务器如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeServer = <span class="keyword">new</span> BasicServer();</span><br><span class="line">nodeServer = nodeServer.decorate(<span class="string">'serveNode'</span>);</span><br><span class="line">nodeServer = nodeServer.decorate(<span class="string">'3000'</span>);</span><br><span class="line">nodeServer.init();</span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中，修饰模式的实现有几种方式。一种方式是通过列表实现，而不是依赖于继承和方法调用链：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BasicServer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.pid = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Initializing basic Server"</span>);</span><br><span class="line">	<span class="keyword">this</span>.decorators_list = []; <span class="comment">//Empty list of decorators</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//List of all decorators</span></span><br><span class="line">BasicServer.decorators = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Add each decorator to the list of BasicServer's decorators</span></span><br><span class="line"><span class="comment">//Each decorator in this list will be applied on the BasicServer instance</span></span><br><span class="line">BasicServer.decorators.reverseProxy = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params">pid</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">"Started Reverse Proxy"</span>);</span><br><span class="line">			<span class="keyword">return</span> pid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">BasicServer.decorators.servePHP = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params">pid</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Started serving PHP"</span>);</span><br><span class="line">		<span class="keyword">return</span> pid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">BasicServer.decorators.serveNode = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params">pid</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Started serving Node"</span>);</span><br><span class="line">		<span class="keyword">return</span> pid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Push the decorator to this list everytime decorate() is called</span></span><br><span class="line">BasicServer.prototype.decorate = <span class="function"><span class="keyword">function</span>(<span class="params">decorator</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.decorators_list.push(decorator);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//init() method looks through all the applied decorators on BasicServer</span></span><br><span class="line"><span class="comment">//and executes init() method on all of them</span></span><br><span class="line">BasicServer.prototype.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> running_processes = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">var</span> pid = <span class="keyword">this</span>.pid;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.decorators_list.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">		decorator_name = <span class="keyword">this</span>.decorators_list[i];</span><br><span class="line">		running_processes = BasicServer.decorators[decorator_name].init(pid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> running_processes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create server to serve PHP</span></span><br><span class="line"><span class="keyword">var</span> phpServer = <span class="keyword">new</span> BasicServer();</span><br><span class="line">phpServer.decorate(<span class="string">'reverseProxy'</span>);</span><br><span class="line">phpServer.decorate(<span class="string">'servePHP'</span>);</span><br><span class="line">total_processes = phpServer.init();</span><br><span class="line"><span class="built_in">console</span>.log(total_processes);</span><br><span class="line"><span class="comment">//Create server to serve Node</span></span><br><span class="line"><span class="keyword">var</span> nodeServer = <span class="keyword">new</span> BasicServer();</span><br><span class="line">nodeServer.decorate(<span class="string">'serveNode'</span>);</span><br><span class="line">nodeServer.init();</span><br><span class="line">total_processes = phpServer.init();</span><br><span class="line"><span class="built_in">console</span>.log(total_processes);</span><br></pre></td></tr></table></figure></p>
<p><strong>BasicServer.decorate()</strong>和<strong>BasicServer.init()</strong>是实际的完成功能的方法。，所有的decorators被添加到<br><strong>BasicServer</strong>的decorators列表. 在<strong>init()</strong>方法中， 执行列表中的每个decorator’s init()方法。这种不需要继承的方式较为简洁，由<em>Stoyan Stefanov</em>在其著作<strong>JavaScript Patterns, O’Reilly Media</strong>中提出。由于其简洁，因此在JavaScript的开发中具有突出地位。</p>
<h2 id="The_observer_pattern"><a href="#The_observer_pattern" class="headerlink" title="The observer pattern"></a>The observer pattern</h2><p>首先看一下与语言无关的关于<strong>观察者模式</strong>的定义。在GOF的<strong>Design Patterns: Elements of Reusable Object-Oriented Software</strong>中, 观察者模式的定义如下：</p>
<p><em>一个或多个观察者对被观察者的状态感兴趣，通过将其本身附加到被观察者以注册兴趣。当被观察者发生观察者感兴趣的变化时，通知消息被发送以调用每个观察者的更新方法。当观察者不再有兴趣时，与被观察者分离就可以 了。</em></p>
<p>在观察者设计模式中，被观察者保留一个对象（观察者）列表，并根据列表在状态发生变化时进行通知。被观察者通过广播通知观察者。观察者在不再想被通知时将其从列表中删除。基于上述理解，观察者模式中参与角色可以进行 如下定义：</p>
<ul>
<li><strong>Subject</strong>: 维护观察者列表，拥有添加、删除和更新观察者的方法</li>
<li><strong>Observer</strong>: 提供当状态发生变化时被通知对象的接收接口</li>
</ul>
<p>下面的例子创建了一个被观察者，可以增加、删除和通知观察者：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Subject = ( <span class="function"><span class="keyword">function</span>(<span class="params"> </span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.observer_list = [];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// this method will handle adding observers to the internal list</span></span><br><span class="line">	Subject.prototype.add_observer = <span class="function"><span class="keyword">function</span> (<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">'Added observer'</span> );</span><br><span class="line">		<span class="keyword">this</span>.observer_list.push( obj );</span><br><span class="line">	&#125;;</span><br><span class="line">	Subject.prototype.remove_observer = <span class="function"><span class="keyword">function</span> (<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.observer_list.length; i++ ) &#123;</span><br><span class="line">			<span class="keyword">if</span>( <span class="keyword">this</span>.observer_list[ i ] === obj ) &#123;</span><br><span class="line">				<span class="keyword">this</span>.observer_list.splice( i, <span class="number">1</span> );</span><br><span class="line">				<span class="built_in">console</span>.log( <span class="string">'Removed Observer'</span> );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Subject.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call( <span class="built_in">arguments</span>, <span class="number">0</span> );</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="keyword">this</span>.observer_list.length; i++ ) &#123;</span><br><span class="line">			<span class="keyword">this</span>.observer_list[i].update(args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> Subject;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>上面是直观的被观察者实现方式。重点是<strong>notify()</strong>方法中，所有观察者对象的<strong>update()</strong>方法通过广播更新的方式调用。<br>接着定义一个简单对象以创建随机tweets. 这个对象提供接口以增加和删除被观察者的观察者对象，即<strong>addObserver()</strong>和<strong>removeObserver()</strong>方法。这个对象也以新获取tweet调用被观察者的<strong>notify()</strong>方法. 当上述情况发生时，所有观察者将广播新tweet已更新，并将新tweet作为参数传递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tweeter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line">	<span class="keyword">this</span>.addObserver = <span class="function"><span class="keyword">function</span> (<span class="params"> observer </span>) </span>&#123;</span><br><span class="line">		subject.add_observer( observer );</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">this</span>.removeObserver = <span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">		subject.remove_observer(observer);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">this</span>.fetchTweets = <span class="function"><span class="keyword">function</span> <span class="title">fetchTweets</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// tweet</span></span><br><span class="line">		<span class="keyword">var</span> tweet = &#123;</span><br><span class="line">			tweet: <span class="string">"This is one nice observer"</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// notify our observers of the stock change</span></span><br><span class="line">		subject.notify( tweet );</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着加入两个观察者：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TweetUpdater = &#123;</span><br><span class="line">	update : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">'Updated Tweet - '</span>, <span class="built_in">arguments</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> TweetFollower = &#123;</span><br><span class="line">	update : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( <span class="string">'"Following this tweet - '</span>, <span class="built_in">arguments</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>两个观察者都有一个<strong>update()</strong>方法被<strong>Subject.notify()</strong>方法调用。现在可以通过<strong>Tweeter</strong>接口将观察者添加到被观察者：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetApp = <span class="keyword">new</span> Tweeter();</span><br><span class="line">tweetApp.addObserver( TweetUpdater );</span><br><span class="line">tweetApp.addObserver( TweetFollower );</span><br><span class="line">tweetApp.fetchTweets();</span><br><span class="line">tweetApp.removeObserver(TweetUpdater);</span><br><span class="line">tweetApp.removeObserver(TweetFollower);</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Added observer</span><br><span class="line">Added observer</span><br><span class="line">Updated Tweet - &#123; '0': [ &#123; tweet: 'This is one nice observer' &#125; ] &#125; "Following this tweet - &#123; '0': [ &#123; tweet: 'This is one nice observer' &#125; ]</span><br><span class="line">&#125; </span><br><span class="line">Removed Observer</span><br><span class="line">Removed Observer</span><br></pre></td></tr></table></figure></p>
<h1 id="JavaScript_Model-View-*_patterns"><a href="#JavaScript_Model-View-*_patterns" class="headerlink" title="JavaScript Model-View-* patterns"></a>JavaScript Model-View-* patterns</h1><p><strong>Model-View-Controller (MVC)</strong>, <strong>Model-View-Presenter (MVP)</strong>, 和<strong>Model-View-ViewModel (MVVM)</strong>是服务器端比较流行，在JavaScript应用中也开始广泛出现，以搭建和管理大型计划。许多支持MV*模式的JavaScript框架也出现了。这里讨论一下<strong>Backbone.js</strong>.</p>
<h2 id="Model-View-Controller"><a href="#Model-View-Controller" class="headerlink" title="Model-View-Controller"></a>Model-View-Controller</h2><p><strong>MVC</strong>是流行的构建模式，主要思想是将应用分为三部分，从而将信息的内部表现从表现层分离。<strong>MVC</strong>由组件构成：<strong>model</strong>是应用对象，<strong>view</strong>是底层model对象的表现，<strong>controller</strong>根据用户交互控制接口行为。</p>
<h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p><strong>Models</strong>是应用里表现数据的结构，对用户接口和流程逻辑一无所知。对models的改变，以观察者设计模式被通知给view层。Models可以包含验证、创建和删除数据的代码。在数据变化时自动通知views以响应的能力使用类似于<strong>Backbone.js</strong>、<strong>Amber.js</strong>等框架，在创建MV<em>应用时有用。下例是典型的<em>*Backbone model</em></em>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EmployeeModel = Backbone.Model.extend(&#123;</span><br><span class="line">	url: <span class="string">'/employee/1'</span>,</span><br><span class="line">	defaults: &#123;</span><br><span class="line">		id: <span class="number">1</span>,</span><br><span class="line">		name: <span class="string">'John Doe'</span>,</span><br><span class="line">		occupation: <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> JohnDoe = <span class="keyword">new</span> EmployeeModel();</span><br></pre></td></tr></table></figure></p>
<p>这类model的结构在不同框架里会有变化，但是它们有共性。.在实际应用中，model常被放在内存store或database以保持一致性.</p>
<h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>Views 是model的可见表现. 通常，model的状态在被views层表现前经过处理、过滤和修饰。在JavaScript里，views负责渲染和操作DOM元素。Views观察models，在其发生变化时被通知。当用户与view交互时, model的特定属性通过view层改变(一般通过controllers). 在JavaScript框架如Backbone中,views由模板引擎创建，如<strong>Handlebar.js</strong> <a href="http://handlebarsjs.com/" target="_blank" rel="external">http://handlebarsjs.com/</a>) 或<strong>mustache.js</strong>(<a href="https://mustache.github.io/" target="_blank" rel="external">https://mustache.github.io/</a>). 这些模板本身不是views. 它们观察models，并根据变化更新其状态。下面是一个<strong>Handlebar</strong>中view定义的例子：<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"employee_photo"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">h2</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">img</span> <span class="attribute">class</span>=<span class="value">"emp_headshot_small"</span> <span class="attribute">src</span>=<span class="value">"&#123;&#123;src&#125;&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"employee_details"</span>&gt;</span></span><br><span class="line">		&#123;&#123;employee_details&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>类似上例中的这些Views，包含有模板变量的markup tags.这些变量由特定的语法限定。<br>例如，在<strong>Handlebar.js</strong>中，模板变量由<code>\{\{ \}\}</code> 限定。框架一般以JSON形式传递数据。 怎样由model构成view, 由框架透明地处理。</p>
<h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>Controllers作为models和views的中间层，负责在用户改变view属性时更新model。大多数t JavaScript框架对经典定义进行了变化。例如，<strong>Backbone</strong>没有叫做controller的概念，但有router负责处理流程逻辑。可以认为view和router的组合是一个controller，因为许多同步models和views逻辑是在view本身完成的。典型的<strong>Backbone router</strong>看起来如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EmployeeRouter = Backbone.Router.extend(&#123;</span><br><span class="line">	routes: &#123; <span class="string">"employee/:id"</span>: <span class="string">"route"</span> &#125;,</span><br><span class="line">	route: <span class="function"><span class="keyword">function</span>(<span class="params"> id </span>) </span>&#123;</span><br><span class="line">		...view render logic…</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="The_Model-View-Presenter_pattern"><a href="#The_Model-View-Presenter_pattern" class="headerlink" title="The Model-View-Presenter pattern"></a>The Model-View-Presenter pattern</h2><p>Model-View-Presenter是原有MVC模式的一种变化。MVC和MVP的目标都是关注点分离，但在许多基础层面有差异。MVP中的presenter有必要的view逻辑。任何来自view的调用被委托给presenter. presenter同时观察model，并在其更新时更新views。许多人认为，由于presenter绑定了views与model, 它也发挥了传统controller的作用。MVP的实现有多种方式，但没有框架提供可用的经典MVP。以下是在MVP的不同实现里，区别于MVC的主要特点:</p>
<ul>
<li>view没有对model的引用</li>
<li>presenter有对model的引用，并负责在模块变化时更新视图<br>MVP常见的两种实现风格：</li>
<li>Passive view: view尽可能简洁，所有业务逻辑在presenter里. 例如，一个普通的Handlebars模板就是一个passive view.</li>
<li>Supervising controller: Views通过包含声明逻辑。presenter在view中的简单声明逻辑不够用时进行接管。<br>下图描述了MVP架构。<br><img src="/./img/1456298832886.png" alt="Alt text"></li>
</ul>
<h2 id="Model-View-ViewModel"><a href="#Model-View-ViewModel" class="headerlink" title="Model-View-ViewModel"></a>Model-View-ViewModel</h2><p>MVVM由Microsoft为Windows Presentation Foundation (WPF) 和Silverlight而创造. MVVM是MVC和MVP 变化形式，进一步尝试从业务模型和应用行为剥离用户界面(view)。MVVM创建了一个新的model层，作为MVC和MVP中domain model的附加。这个model层添加属性以作为视图的接口。例如，在UI里有一个核选框，它的状态由<strong>IsChecked</strong>捕获。在MVP里，视图拥有这个属性，而presenter设置这个属性。但在 MVVM里, presenter拥有IsChecked属性，视图负责进行同步。 presenter不再做Classical presenter的工作, 因此被称作ViewModel:<br><img src="/./img/1456299352133.png" alt="Alt text"></p>
</div></article><div class="pagination"><a href="/2016/02/26/Node简介/" class="pagination-prev">PREV</a><a href="/2016/02/22/Closures/" class="pagination-next">NEXT</a></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browserify/">Browserify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Callback/">Callback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Closure/">Closure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Table Layout in CSS/">Table Layout in CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Exam Analysis/">Exam Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/JQuery EasyUI Sourece Code Analysis/">JQuery EasyUI Sourece Code Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/AngularJS/">Angular</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/demystifying-javascript-closures-callbacks-iifes/">demystifying-javascript-closures-callbacks-iifes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Browserify/">Browserify</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/strict-mode/">strict mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/Try{} and Catch{}/">Try{} and Catch{}</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2016 <a href="/">Tilly Vally</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>