<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Node简介 · Hexo of Tilly Vally @ GitHub</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">主页</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   博客</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li><li class="nav-list-item"><a href="https://github.com/xxxxx" target="_blank" class="nav-link">   github</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/02/26/Node简介/" class="post-title-link">Node简介</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Event/" class="post-tag-link">Event</a></li><li class="post-tag-item"><a href="/tags/JavaScript/" class="post-tag-link">JavaScript</a></li><li class="post-tag-item"><a href="/tags/Node/" class="post-tag-link">Node</a></li><li class="post-tag-item"><a href="/tags/Timers/" class="post-tag-link">Timers</a></li></ul><div class="post-time">星期五, 七月 15日 2016</div></div><div class="post-content"><h1 id="u6D4F_u89C8_u5668_u4E2D_u7684_u5F02_u6B65_u4E8B_u4EF6_u6A21_u578B"><a href="#u6D4F_u89C8_u5668_u4E2D_u7684_u5F02_u6B65_u4E8B_u4EF6_u6A21_u578B" class="headerlink" title="浏览器中的异步事件模型"></a>浏览器中的异步事件模型</h1><p>浏览器和Node在使用I/O时都是事件驱动和非阻塞式的。下表是不同操作及成本的比较：<br>|          Operation              |         Cost      |<br>| :——————:  | :——————-: |<br>| L1 cache read         | 0.5 nanoseconds        |<br>| L2 cache read         | 7 nanoseconds |<br>| RAM | 100 nanoseconds |<br>| Read 4 KB randomly from SSD  | 150,000 ns |<br>| Read 1 MB sequentially from SSD | 1,000,000 ns |<br>| Read 1 MB sequentially from disk | 20,000,000 ns |</p>
<p>I/O操作一般比较耗时，等待会降低程序运行速度：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">var</span> log = fileSystemReader.read(<span class="string">"./verybigfile.txt"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br></pre></td></tr></table></figure></p>
<p>当调用<strong>fileSystemReader.read()</strong>时，从系统读取文件。取决于硬件、文件系统和操作系统等，由于读取完成需要较长时间，这一操作会阻塞整个程序的执行。上面的代码是传统的I/O模式，进程会等待（被阻塞）读取完成。这会非常耗时，且分配给进程的资源也会被占用。</p>
<p>如果发生I/O阻塞, Node服务器拒绝新请求。有若干方式解决这一问题。最普通的常见方式是使用多线程处理请求。<br>浏览器的处理方式不一样。浏览器的I/O操作在主线程之外，当I/O完成时会触发事件。该事件由与事件相关的回调函数处理。这种类型的I/O是非阻塞和异步模式的。由于I/O并不阻塞主执行线程，浏览器可以继续处理其他事件而不用等待I/O. 异步I/O使浏览器可以响应多个事件，实现更高水平的交互性。<br>Node使用类似的概念进行异步处理。Node’s事件循环以单线程方式运行。这意味着应用本质上都是单线程的。但Node自身不是单线程的。Node使用<strong>libuv</strong>因此是多线程的.</p>
<p>每个需要I/O操作的调用都需要注册回调函数。回调函数的注册是异步并立即返回的。当I/O操作完成时，其回调函数被加入事件循环。在其他之前的加入的回调函数执行完成后执行。所有操作本质上是线程安全的，因为事件循环没有需要同步的并行执行路径。</p>
<p>本质上，只有一个线程执行代码，没有并行线程。但除了你的代码之外，其他都是并行。<br>Node.js依赖<strong>libev</strong> (<a href="http://software.schmorp.de/pkg/libev.html)实现事件循环，**libeio**" target="_blank" rel="external">http://software.schmorp.de/pkg/libev.html)实现事件循环，**libeio**</a> (<a href="http://software.schmorp.de/pkg/libeio.html)是其补充以利用线程池提供异步I/O" target="_blank" rel="external">http://software.schmorp.de/pkg/libeio.html)是其补充以利用线程池提供异步I/O</a>.<br>下面是一段Node.js里的异步代码段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">fs.readFile(<span class="string">'./response.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!error)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(data);</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码里，从磁盘读取<strong>response.json</strong>文件。当磁盘I/O完成时，回调函数被调用. 在控制台的输出为<code>console.log(&#39;1&#39;)</code> 和<code>console.log(&#39;2&#39;)</code>，一个紧跟着另一个:<br><img src="/./img/1456304332134.png" alt="Alt text"><br>Node.js不需要额外的服务器组件，它自己就可以创建服务器进程。Node应用就是运行在指定端口上的服务器。在Node里，server和application是同样的。<br>下面是一个例子，当浏览器加载URL<a href="http://localhost:3000/时，Node.js服务响应" target="_blank" rel="external">http://localhost:3000/时，Node.js服务响应</a> 字符串<strong>Hello Node</strong>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">	res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">	res.end(<span class="string">'Hello Node\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上例中使用 了http模块.  这是一个CommonJS模块实现. Node可执行binary有多个已编译模块。内核模块在Node’s源码中定义，其位置在<strong>lib/</strong>文件夹下.传给<strong>require()</strong>的标识符代表的内核模块首先被加载。例如，<strong>require(‘http’)</strong>问题首先返回内建的HTTP模块，即使存在一个该名称的文件。<br>加载处理HTTP请求的模块后，创建一个服务器对象，使用函数<strong>server.on()</strong>监听<strong>request</strong>事件。当请求服务器端口3000的事件发生时，回调函数接收<strong>request</strong>和<strong>response</strong>参数。 在返回响应前，设置<strong>Content-Type</strong> 头和HTTP响应代码。将上面的代码保存为app.js，以命令行方式启动服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ » node app.js</span><br></pre></td></tr></table></figure></p>
<p>服务器启动完毕，在浏览器中打开<a href="http://localhost:3000，显示如下结果：" target="_blank" rel="external">http://localhost:3000，显示如下结果：</a><br><img src="/./img/1456370889201.png" alt="Alt text"></p>
<p>如果需要了解内部发生了什么，可按如下方式执行 <strong>curl</strong>命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~ » curl -v http://localhost:<span class="number">3000</span></span><br><span class="line">* Rebuilt URL to: http://localhost:<span class="number">3000</span>/</span><br><span class="line">* Trying ::<span class="number">1</span>…</span><br><span class="line">* Connected to localhost (::<span class="number">1</span>) port <span class="number">3000</span> (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: localhost:<span class="number">3000</span></span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.43</span>.<span class="number">0</span></span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;&lt;</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">&lt; Content-Type: text/plain</span><br><span class="line">&lt; Date: Thu, <span class="number">12</span> Nov <span class="number">2015</span> <span class="number">05</span>:<span class="number">31</span>:<span class="number">44</span> GMT</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Hello Node</span><br><span class="line">* Connection <span class="comment">#0 to host localhost left intact</span></span><br></pre></td></tr></table></figure></p>
<p>Curl显示了request (&gt;)和response (&lt;)对话过程，包括request和response headers.</p>
<h2 id="u56DE_u8C03"><a href="#u56DE_u8C03" class="headerlink" title="回调"></a>回调</h2><p>在Node里，所有的事件都是异步的，回调无需仔细设计。Node.js最重要的方面是代码组织和模块管理。<br>Callbacks是在以后的某个时间点异步执行的函数. 与从上到下的代码阅读顺序相反，异步程序基于顺序和速度在不同的时候点执行不同的函数. 函数是否顺序或异步执行取决于上下文环境：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">	i=i+num;</span><br><span class="line">&#125; </span><br><span class="line">add(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure></p>
<p>如果在Node里运行上面的代码，输出结果如下(假定文件名为app.js):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/Chapter9 » node app.js</span><br><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>这是传统的代码同步执行方式，一行接一行执行。 这是一种顺序控制流。当在其中引入I/O操作时，例如读文件或远程调用，Node会以异步方式执行。在下面的例子中，Node.js的模块<strong>request</strong>用于HTTP调用。该模块的安装方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install request</span><br></pre></td></tr></table></figure></p>
<p>看一下下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">var</span> status = <span class="literal">undefined</span>;</span><br><span class="line">request(<span class="string">'http://google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">		status_code = response.statusCode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(status);</span><br></pre></td></tr></table></figure></p>
<p>当运行这个例子时，变量<strong>status</strong>的值仍然是<strong>undefined</strong>. 这里的HTTP调用是一个I/O操作，因此执行过程是异步的。虽然所有函数都是定义好的，但并不是全部立即执行的。<strong>request()</strong>函数被调用后，接着执行下一行代码。如果后面没有代码，Node或者等待I/O返回，或者退出。当<strong>request()</strong>完成其工作时，会调用回调函数 (这里的回调是一个匿名函数，是<strong>request()</strong>函数 的第二个参数). 输出<code>undefined</code>是因为，代码中没有让<code>console.log()</code>等待<strong>request()</strong>函数完成以从HTTP调用中获取信息。</p>
<p>回调函数在以后某个时间点执行这一特点，改变了代码组织方式。重新组织的要点如下：</p>
<ul>
<li>将异步代码打包在一个函数中</li>
<li>把回调函数传递给打包函数<br>按照这个思路，前例代码修改如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"><span class="keyword">var</span> status = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSiteStatus</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">	request(<span class="string">'http://google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">			status_code = response.statusCode;</span><br><span class="line">		&#125;</span><br><span class="line">		callback(status_code);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showStatusCode</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(status);</span><br><span class="line">&#125; </span><br><span class="line">getSiteStatus(showStatusCode);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在可以得到正确的输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$node</span> app.js</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure></p>
<p>这里异步代码被打包到<strong>getSiteStatus()</strong>函数中，名称为<strong>callback()</strong>的函数作为这个函数的参数, <strong>callback()</strong>在<strong>getSiteStatus()</strong>的最后一行执行。<strong>showStatusCode()</strong>回调函数简单地将<code>console.log()</code>打包在内部。与回调编程有关的一个最重要的的概念是：<strong>函数是一等对象，可存储在变量中，可以不同名称传递</strong>。现在，在HTTP调用完成后，回调函数被调用, 得到变量<strong>status_code</strong>的值。存在这样的应用场景：仅在另一个异步任务完成后才执行一个异步任务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(<span class="keyword">function</span> (req, res) &#123;</span><br><span class="line">	getURL(url, <span class="keyword">function</span> (err, res) &#123;</span><br><span class="line">		getURLContent(res.data, <span class="keyword">function</span>(err,res) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如你所见，一个异步函数嵌套在另一个异步函数里。这样的嵌套使代码难以阅读和管理，通常被称为callback hell. 为了避免类似情况，在需要等待某些其他异步任务完成时，将代码放入被传递的回调函数，来表现这种依赖关系。另一点重要的是，命名函数而不是使用匿名函数作为回调。将上面那个例子重构后的代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urlContentProcessor = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> urlResponseProcessor = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	getURLContent(data,urlContentProcessor);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> createServer = <span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">	getURL(url,urlResponseProcessor);</span><br><span class="line">&#125;;</span><br><span class="line">http.createServer(createServer);</span><br></pre></td></tr></table></figure></p>
<p>这里有两个重要的概念。首先，使用命名函数，并将其作为回调函数。其次，没有嵌套。<br>Callbacks在Node中经常用于定义一次性响应的业务逻辑。Node有专门对重复事件进行处理的机制。但首先要理解Node里的计时器和事件的概念。</p>
<h2 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h2><p>Timers用于在给定延迟后有计划地执行一个特定回调。有两种方式设定延迟执行：<strong>setTimeout</strong>和<strong>setInterval</strong>. <strong>setTimeout()</strong>用于在设定的延迟后执行一个回调,而<strong>setInterval</strong>用于周期性地重复执行回调。看一下下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"This is just one time delay"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="built_in">console</span>.log(count);</span><br><span class="line">	<span class="keyword">if</span> (count&gt; <span class="number">5</span>)&#123;</span><br><span class="line">		clearInteval(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">2000</span> );</span><br></pre></td></tr></table></figure></p>
<p>一开始，<strong>setTimeout()</strong>在延迟1000ms后执行一个异步回调函数. 这是一个一次性计划。重复执行则使用<strong>setInterval()</strong>. 注意，<strong>setInterval()</strong>返回变量<strong>t</strong>，在<strong>clearInterval()</strong>中通过这个引用清除该计划。</p>
<h2 id="EventEmitters"><a href="#EventEmitters" class="headerlink" title="EventEmitters"></a>EventEmitters</h2><p>EventEmitters用于响应重复事件。EventEmitters触发事件，包含事件处理能力。很多重要的Node APIs基于EventEmitters构建.<br>由EventEmitters引起的Events通过listeners处理. 一个listener就是关联到一个事件的回调函数。当事件触发时，关联的listener也被触发。事件的EventEmitter是一个类，用于提供接口一致性，以发送（触发）和绑定事件的回调。<br>作为风格传统，事件名称为camel-cased字串;但所有有效字串都可以作为事件名。<br>使用<code>require(&#39;events&#39;)</code>以访问<strong>EventEmitter</strong>类:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br></pre></td></tr></table></figure></p>
<p>当EventEmitter实例出错时，触发一个<code>error</code>事件。在Node.js中，<code>error</code>事件被特殊对待。如果不对其进行处理，程序会以异常堆栈退出。<br>EventEmitters在添加监听器时发送<code>newListener</code>事件，在移除监听器时发送<code>removeListener</code>事件。</p>
<p>为了理争EventEmitters, 下面搭建一个简单的telnet服务器，客户端可以登录并输入特定的命令，服务器返回相应的响应：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> _events = <span class="built_in">require</span> (<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> _emitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line">_emitter.on(<span class="string">'join'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">id,caller</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(id+<span class="string">" - joined"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">_emitter.on(<span class="string">'quit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">id,caller</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(id+<span class="string">" - left"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _server = _net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">caller</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> process_id = caller.remoteAddress + <span class="string">':'</span> + caller.remotePort;</span><br><span class="line">	_emitter.emit(<span class="string">'join'</span>,id,caller);</span><br><span class="line">	caller.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"disconnected"</span>);</span><br><span class="line">		_emitter.emit(<span class="string">'quit'</span>,id,caller);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">_server.listen(<span class="number">8124</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个代码片段使用了Node中的<strong>net</strong>模块，服务器可以通过标准的<strong>telnet</strong>命令连接。当客户端连接时，服务器显示客户端地址和端口，客户端退出时，服务器也进行记录。当客户端连接时，触发<strong>join</strong>事件，断开时，触发<strong>quit</strong>事件。运行程序，并进行连接：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">8124</span></span><br></pre></td></tr></table></figure></p>
<p>在服务器控制台，日志输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">» node app.js</span><br><span class="line">::ffff:<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">51000</span> - joined</span><br><span class="line">::ffff:<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">51001</span> – joined</span><br></pre></td></tr></table></figure></p>
<p>退出时也会有相应的消息显示。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Node模块是CommonJS模块模式，通过<strong>Node Package Manager (npm)</strong>发布. </p>
<p>Node modules可以是单文件，也可以是包含一个或以上文件的路径。好的做法是建立独立的模块路径. 在模块路径下被评估的文件名为<strong>index.js</strong>. 模块路径的例子一般如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_project/src/<span class="tag">nav</span></span><br><span class="line">				--- &gt;index.js</span><br></pre></td></tr></table></figure></p>
<p>在计划路径下，<strong>nav</strong>模块路径包含模块代码。模块代码一般在index.js里—也可以改成其他文件。下面是geo.js这个小模块的例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * r * r;</span><br><span class="line">&#125;;</span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * <span class="number">3.14</span> * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>exports</code>导出两个函数. <code>require</code>引入模块，以模块名或模块代码的系统路径为参数。<strong>geo.js</strong>的使用如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geo = <span class="built_in">require</span>(<span class="string">'./geo.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(geo.area(<span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>除了导出的两个函数，其他都是私有的。Node使用CommonJS模式。还有另一种编写模块的的语法。使用<strong>modules.exports</strong>导出模块。当使用<strong>exports</strong>时, 被导出的模块属性被附加到<strong>modules.exports</strong>. 然而，如果<strong>modules.exports</strong>已经有属性附加过，由<strong>exports</strong>附加的属性被忽略。<br><strong>geo</strong>模块可重写以返回单个<strong>Geo</strong>构造函数，而不是包含函数的一个对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Geo = <span class="function"><span class="keyword">function</span>(<span class="params">PI</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.PI = PI;</span><br><span class="line">&#125; </span><br><span class="line">Geo.prototype.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line">Geo.prototype.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.PI * <span class="keyword">this</span>.PI * r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = Geo;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个<strong>config.js</strong>模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db_config = &#123;</span><br><span class="line">	server: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">	port: <span class="string">"3306"</span>,</span><br><span class="line">	user: <span class="string">"mysql"</span>,</span><br><span class="line">	password: <span class="string">"mysql"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = db_config;</span><br></pre></td></tr></table></figure></p>
<p>如果从模块外部访问<strong>db_config</strong>，方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./config.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(config.user);</span><br></pre></td></tr></table></figure></p>
<p>组织模块有三种方法：</p>
<ul>
<li>使用相对路径，例如<code>config = require(&#39;./lib/config.js&#39;)</code></li>
<li>使用绝对路径，例如<code>config = require(&#39;/nodeproject/lib/config.js&#39;)</code></li>
<li>使用模块查找，例如<code>config = require(&#39;config&#39;)</code></li>
</ul>
<p>第三种方式，Node会以标准的查找方式定位模块：从当前路径开始，添加<code>./node_modules/</code>，开始查找.如果没找到，则在上一层路径查找，直到系统根目录。<br>例如，<code>require(&#39;config&#39;)</code> 在<code>/projects/node/</code>下被调用, 下面是路搜索的顺序：</p>
<ul>
<li>/projects/node /node_modules/config.js</li>
<li>/projects/node_modules/config.js</li>
<li>/node_modules/config.js</li>
</ul>
<p>对于从npm下载的模块，这种方法相对简单。也可以在特定路径中组织模块，只要给Node提供入口.<br>最容易的方式是创建<code>./node_modules/supermodule/</code>路径，在这个路径下插入index.js文件。<strong>index.js</strong>被默认加载。<br>其他可行方式是，在<strong>mymodulename</strong>路径下放一个<strong>package.json</strong>文件，其中定义模块的名称和主文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"<span class="attribute">name</span>": <span class="value"><span class="string">"supermodule"</span></span>,</span><br><span class="line">	"<span class="attribute">main</span>": <span class="value"><span class="string">"./lib/config.js"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>Node以对象方式缓存模块. 如果有两个以上文件请求同一个模块，第一个<strong>require</strong>在内存中缓存模块，第二个不需要从源码重新加载模块。但是，第二个<strong>require</strong>可以改变模块功能。这通常被叫做<br><strong>monkey patching</strong>，用于修改模块行为而实际改变原有模块。</p>
</div></article><div class="pagination"><a href="/2016/02/26/Try{} and Catch{}/" class="pagination-prev">PREV</a><a href="/2016/02/24/Patterns/" class="pagination-next">NEXT</a></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browserify/">Browserify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Callback/">Callback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Closure/">Closure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Table Layout in CSS/">Table Layout in CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Exam Analysis/">Exam Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/JQuery EasyUI Sourece Code Analysis/">JQuery EasyUI Sourece Code Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/AngularJS/">Angular</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/demystifying-javascript-closures-callbacks-iifes/">demystifying-javascript-closures-callbacks-iifes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Browserify/">Browserify</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/strict-mode/">strict mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/Try{} and Catch{}/">Try{} and Catch{}</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2016 <a href="/">Tilly Vally</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>