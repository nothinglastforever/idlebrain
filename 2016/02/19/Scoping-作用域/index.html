<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Scoping 作用域 · Hexo of Tilly Vally @ GitHub</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">主页</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   博客</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li><li class="nav-list-item"><a href="https://github.com/xxxxx" target="_blank" class="nav-link">   github</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/02/19/Scoping-作用域/" class="post-title-link">Scoping 作用域</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Function/" class="post-tag-link">Function</a></li><li class="post-tag-item"><a href="/tags/JavaScript/" class="post-tag-link">JavaScript</a></li><li class="post-tag-item"><a href="/tags/Scope/" class="post-tag-link">Scope</a></li></ul><div class="post-time">星期五, 七月 15日 2016</div></div><div class="post-content"><h1 id="Scoping__u4F5C_u7528_u57DF"><a href="#Scoping__u4F5C_u7528_u57DF" class="headerlink" title="Scoping 作用域"></a>Scoping 作用域</h1><p>在javascripts中，scope 定义为代码当前的执行环境（the current context of code）。<br>变量的scope是该变量存在的环境。scope指定从哪里可以访问该变量。每个执行环境都有一个与之关联的<em>变量对象（variable object）</em>,<br>执行环境中定义的所有变量和函数都保存在这个对象中。编写的代码无法直接访问这个对象，但解析器在后台处理数据时使用它。某个执行环境中的所有代码执行完毕后，<br>该环境被销毁，保存在其中的所有变量和函数定义随之销毁。全局执行环境在应用程序退出时被销毁，如关闭网页或浏览器。</p>
<h2 id="Global_Scope__u5168_u5C40_u4F5C_u7528_u57DF"><a href="#Global_Scope__u5168_u5C40_u4F5C_u7528_u57DF" class="headerlink" title="Global Scope 全局作用域"></a>Global Scope 全局作用域</h2><p>全局执行环境是最外围的一个执行环境。在WEB浏览器中，全局执行环境被认为是<code>window</code>对象。任何声明的变量默认其作用域为全局。全局变量对所有其他作用域可见。<br>全局变量使得在同一程序或模块中，运行松耦合的各子程序变得困难。如果子程序碰巧与全局都有同一个变量名，相互之间会产生干扰，难以调试错误。这就是所说的命名空间碰撞。</p>
<h2 id="Local_Scope__u672C_u5730_u4F5C_u7528_u57DF"><a href="#Local_Scope__u672C_u5730_u4F5C_u7528_u57DF" class="headerlink" title="Local Scope 本地作用域"></a>Local Scope 本地作用域</h2><p>Javascripts不像其他语言那样有区块级作用域（由花括号划分的代码区块）；但javascrips有函数级作用域。在函数中声明的变量为本地作用域变量，只能在函数中访问，或者是由该函数内部的函数访问。<br>每个函数在被调用时都会创建自己的执行环境。当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中。而在函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope_name = <span class="string">"Global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showScopeName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// local variable; only accessible in this function</span></span><br><span class="line"><span class="keyword">var</span> scope_name = <span class="string">"Local"</span>;</span><br><span class="line"><span class="built_in">console</span>.log (scope_name); <span class="comment">// Local</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log (scope_name); <span class="comment">//prints -Global</span></span><br><span class="line">showScopeName(); <span class="comment">//prints – Local</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u51FD_u6570_u7EA7scope__u4E0E__u533A_u5757_u7EA7scope__u5BF9_u6BD4"><a href="#u51FD_u6570_u7EA7scope__u4E0E__u533A_u5757_u7EA7scope__u5BF9_u6BD4" class="headerlink" title="函数级scope 与 区块级scope 对比"></a>函数级scope 与 区块级scope 对比</h2><p>JavaScript 变量由函数划分作用域。可将其想像为不断生成的小气泡，以防止气泡外部看见内部。函数为其内部声明的变量生成这样的气泡。 大概的情形如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-GLOBAL SCOPE---------------------------------------------|</span><br><span class="line"><span class="keyword">var</span> g =<span class="number">0</span>; 												  |</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; -----------------------|                |</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;                               |                |</span><br><span class="line"><span class="comment">//code 									 | 				  |</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; ------|				 |				  |</span><br><span class="line"><span class="comment">// ... 				   |ScopeBar 		 |ScopeFoo 		  |</span></span><br><span class="line">&#125; 				 ------| 				 |				  |</span><br><span class="line"><span class="comment">// code									 |				  |</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">2</span>; 								 |				  |</span><br><span class="line">&#125;----------------------------------------|				  |</span><br><span class="line">foo(); <span class="comment">//WORKS 											  |</span></span><br><span class="line">bar(); <span class="comment">//FAILS                                            |</span></span><br><span class="line">----------------------------------------------------------|</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 使用<em>作用域链</em>（scope chains）为给定的函数建立作用域。 作用域链的排第一位的始终是当前执行代码所在执行环境的变量对象。如果这个执行环境是一个函数，则将其<em>活动对象(activation object）</em>作为变量对象典型地有一个全局域，每个定义的函数有它自已的嵌套域。任何在其他函数内部定义的内部函数，其作用域链接到它的外部函数。 <em>原始位置</em> 定义作用域。当解析变量时，JavaScript由最内层开始，逐步向外，一级一级地搜索标识符。 </p>
<p>在上面的例程中，<strong>foo()</strong>函数在全局域中定义,<strong>foo()</strong>函数有自已的本地域，它也可以访问全局变量<strong>g</strong>.  <strong>a</strong>，<strong>b</strong>,<strong>c</strong>三个变量在本地域中可以访问。<strong>bar()</strong>函数与三个变量的作用域一样，当<strong>foo()</strong>函数返回后，不再可以被调用（在<strong>foo()</strong>函数的气泡之外是不可见的）。</p>
<p><strong>bar()</strong>函数拥有自已的函数域, 它可以访问<strong>foo()</strong>函数及所有在<strong>foo()</strong>函数域（它的父域）中创建的变量-<strong>a</strong>，<strong>b</strong>,<strong>c</strong>。<strong>bar()</strong>函数也可以访问全局变量，<strong>g</strong>.</p>
<p>因此，如果将任意一部分代码打包在函数内，就可以隐藏和创建这部分代码的一个作用域（气泡）。通过<strong>函数打包代码方式创建作用域</strong>可以帮助创建正确的代码，避免难以调试的bugs。函数作用域和在期中隐藏变量和函数的另一个优点是，避免两个标识符的冲突。下面是一个坏例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">		i = <span class="number">2</span>; <span class="comment">// changing the 'i' in the enclosing scope's for-loop</span></span><br><span class="line">		<span class="built_in">console</span>.log(a+i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">		bar(i); <span class="comment">// infinite loop</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>在<strong>bar()</strong>函数中，无意中修改了 <strong>i=2</strong>. 当在<strong>for</strong>循环中调用<strong>bar()</strong> 时，变量<strong>i</strong> 的值被设为2，形成死循环。 这是命名空间冲突的一个坏例子。</p>
<p>目前为止，在Javascript中使用函数作用域以实现模块化和正确性，听起来是一个不错的方式. 尽管这种方式可行，但并不真得很理想。第一个问题，必须创建一个命名函数。如果一直这样创建函数以引入函数作用域，全局作用域或父作用域会充满这样的代码。此外，还需要调用这样的函数。这会引入很多样板，随着时间推移代码会越来越难读:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//Lets introduce a function -scope</span></span><br><span class="line"><span class="comment">//1. Add a named function foo() into the global scope</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. Now call the named function foo()</span></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>通过创建函数<strong>foo()</strong>引入了函数域，紧跟着在后面调用函数执行代码。在JavaScript中, 通过创建立即执行的函数可以解决上述两个问题。仔细研究下面这个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//Lets introduce a function -scope</span></span><br><span class="line"><span class="comment">//1. Add a named function foo() into the global scope</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;)(); <span class="comment">//&lt;---this function executes immediately</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>(function foo(){ })</strong>这种表达方式的意思是将<strong>foo()</strong>函数作为函数表达式，而不是作为一个函数声明。标识符<strong>foo</strong>只在<strong>foo()</strong>函数作用域内存在，外部不可见。将<strong>foo</strong>隐藏在其自身内部，避免对所在作用域产生干扰。在函数表达式后加<strong>()</strong>，指示函数立即执行。完整的模式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure></p>
<p>这种模式有一通用的名字：<strong>IIFE</strong>, 即<strong>Immediately Invoked Function Expression</strong>. 很多程序员在使用IIFE时省略函数名。由于IIFE的主要作用是引入函数域，命名函数并不是必要的。前面的例子也可以变成如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>上面是IIFE的匿名函数形式，与前面的命名函数形式功能一样, 但匿名IIFE函数有一些缺点：</p>
<ul>
<li>在堆栈中找不到函数名，难以调试。</li>
<li>不能使用递归调用</li>
<li>过度使用匿名IIFEs有时会导致代码难以阅读<br>Douglas Crockford 和其他一些专家建议使用如下变化的IIFE:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>两种形式都很常见。同时可以给IIFEs传递参数. 下面的例子演示了如何传递参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log( a + b );</span><br><span class="line">&#125;)(<span class="number">3</span>); <span class="comment">//prints 5</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Inline_function_expressions"><a href="#Inline_function_expressions" class="headerlink" title="Inline function expressions"></a>Inline function expressions</h2><p>内联函数表达式是另一种常见用法，即将函数作为参数传递给另一个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setActiveTab</span>(<span class="params">activeTabHandler, tab</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//set active tab</span></span><br><span class="line">	<span class="comment">//call handler</span></span><br><span class="line">	activeTabHandler();</span><br><span class="line">&#125;</span><br><span class="line">setActiveTab( <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log( <span class="string">"Setting active tab"</span> );</span><br><span class="line">&#125;, <span class="number">1</span> );</span><br><span class="line"><span class="comment">//prints "Setting active tab"</span></span><br></pre></td></tr></table></figure></p>
<p>同样，可以命名内联函数以保证在调试代码时可以跟踪堆栈。</p>
<h2 id="Block_scopes"><a href="#Block_scopes" class="headerlink" title="Block scopes"></a>Block scopes</h2><p>与C和Java不同，Javascript中没有块作用域这个概念。<strong>ECMAScript 6 (ES6) </strong>引入了<strong>let</strong>关键字，以引入传统的块作用域. 如果环境支持ES6, 就可以使用<strong>let</strong>关键字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">	<span class="keyword">let</span> bar = <span class="number">42</span>; <span class="comment">//variable bar is local in this block &#123; &#125;</span></span><br><span class="line">	<span class="built_in">console</span>.log( bar );</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">console</span>.log( bar ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></p>
<p>通常代码是以自上而下的方式一行接一行顺序执行的，大部分的JavaScript代码也一样，但有部分例外：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 1-a</span></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>显然上面的代码无效，结果会是在调用console.log()出错，a是<strong>undefined</strong>。下面的代码输出是什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 1- b</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure></p>
<p>理所当然地预期输出为<strong>undefined</strong>, 因为<strong>var a</strong>在<strong>a = 1</strong>之后, 好像变量<strong>a</strong>被重新定义并被赋值为默认的初始值<strong>undefined</strong>. 但实际输出是<strong>1</strong>.</p>
<p>当看到<strong>var a = 1</strong>时, JavaScript将其拆分为两个表达式:<strong>var a</strong> 和<strong>a = 1</strong>. 第一个变量声明表达式在编译阶段处理。第二个赋值表达式在执行阶段处理。因此前面的代码(1b)实际执行过程如下(1c)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 1- c 对应 1 - b</span></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">//----Compilation phase</span></span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//------execution phase</span></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure></p>
<p>The first snippet is actually executed as follows:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 1- d 对应 1 - a</span></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">//-----Compilation phase</span></span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//------execution phase</span></span><br></pre></td></tr></table></figure></p>
<p>可见，变量和函数声明在编译阶段被移动到最前面，这一过程被熟称为hoisting. 重要的是要记住只有声明本身被提升，任何赋值或其他可执行逻辑不动。下面的代码演示了函数声明如何提升：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<strong>foo()</strong>的声明被提升，因此可以在被定义前就被调用。提升在每个作用域内生效。在<strong>foo()</strong>函数内，变量的声明被提升到函数顶部，而不是程序顶部。伴随的提升的<strong>foo()</strong>函数实际执行顺序如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a;</span><br><span class="line">	<span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数声明被提升，但函数表达式不会。</p>
<h2 id="Function_declarations__u4E0E_function_expressions_u5BF9_u6BD4"><a href="#Function_declarations__u4E0E_function_expressions_u5BF9_u6BD4" class="headerlink" title="Function declarations 与 function expressions对比"></a>Function declarations 与 function expressions对比</h2><p>这两种定义方式目的一致，但有所区别。检视下面的例程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function expression</span></span><br><span class="line">functionOne();</span><br><span class="line"><span class="comment">//Error</span></span><br><span class="line"><span class="comment">//"TypeError: functionOne is not a function</span></span><br><span class="line"><span class="keyword">var</span> functionOne = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"functionOne"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Function declaration</span></span><br><span class="line">functionTwo();</span><br><span class="line"><span class="comment">//No error</span></span><br><span class="line"><span class="comment">//Prints - functionTwo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTwo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"functionTwo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数声明在其出现时被处理，这发生在任何step-by-step代码被执行之前。这个被创建的函数被正式命名(上面代码中的<strong>functionTwo()</strong>) ，这个函数名被放置在声明出现的作用域中。因为是在同一环境下的任何代码被执行前处理，在定义前调用<strong>functionTwo() </strong>不会发生错误。但<strong>functionOne()</strong>是一个匿名函数表达式， 在代码的step-by-step执行过程中当前进到这里时才被评估(也被称为runtime execution); 必须在调用之前声明它。本质上，函数<strong>functionTwo()</strong>的声明被提升，而<strong>functionOne()</strong>的表达式在到达它时被执行。</p>
<p><em>注意：函数与变量的声明都被提升，但函数在前，变量在后。</em></p>
<p>永远不要在条件判断情况下进行函数声明。这种方式不标准，在不同平台的表现也不一样。下面的例程演示了在条件判断下进行函数声明，尝试定义<strong>sayMoo()</strong>函数的不同函数体。该代码不能保证在所有浏览器上正常运行，结果不可预期:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Never do this - different browsers will behave differently</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayMoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'trueMoo'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sayMoo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'falseMoo'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>但对函数表达式做同样的事是安全的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayMoo;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	sayMoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'trueMoo'</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	sayMoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'falseMoo'</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; </span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>函数声明只允许在程序或函数体中出现。但不能在块(<strong>{ … }</strong>)中出现. 块只能包含陈述而不是声明。基于此，几乎所有的JavaScript实现对此表现都不一样。 在条件执行块中永远不要进行函数声明。<br>另一方面，函数表达式在条件块中的应用很常见。Javascrip中的一种常见模式是基于某个条件来 fork 函数定义. 这样的 forks 通常在同一个作用域中出现，因此几乎总是使用函数表达式。</p>
<h2 id="arguments_u53C2_u6570"><a href="#arguments_u53C2_u6570" class="headerlink" title="arguments参数"></a><strong>arguments</strong>参数</h2><p><strong>arguments</strong>参数就是传递给函数的所有实参的一个集合。集合有一个名为length的属性，包含实参个数，单个的实参值通过数组索引获取。 <strong>arguments</strong>参数其实不是JavaScript数组，如果对其使用数组方法，肯定会出错。 可将其看成是类似数组的结构。这样就可创建不确定形参个数的函数。下面的例程演示了如何传递可变数量的实参给函数，并进行枚举：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i, total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">		total += <span class="built_in">arguments</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)); <span class="comment">// prints 45</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)); <span class="comment">// prints 15</span></span><br></pre></td></tr></table></figure></p>
<p>虽然<strong>arguments</strong>参数不是一个真的数组，但可以转换为数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure></p>
<p>转换后，就可以按数组进行处理。</p>
<h2 id="this_u53C2_u6570"><a href="#this_u53C2_u6570" class="headerlink" title="this参数"></a><strong>this</strong>参数</h2><p>当调用函数时，除了在调用时提供的明显的实参参数，一个名为<strong>this</strong>的隐形参数也被传递给函数。它指向一个与函数调用关联的隐形对象, 术语为a function context函数上下文环境. 与Java类似，这个关键字指向一个类实例，该方法在这个类实例中定义。<br>下面讨论函数的调用方式。</p>
<h2 id="u4F5C_u4E3A_u51FD_u6570_u8C03_u7528"><a href="#u4F5C_u4E3A_u51FD_u6570_u8C03_u7528" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>如果函数不是作为method, constructor, 或通过apply() 、call()调用，那就是作为函数调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">add();</span><br><span class="line"><span class="keyword">var</span> substract = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">substract();</span><br></pre></td></tr></table></figure></p>
<p>当函数以这种方式调用时，<strong>this</strong>绑定到<strong>global object</strong>。许多专家认为这是一个糟糕的设计。自然的想法是将<strong>this</strong>绑定到父上下文环境。</p>
<h2 id="u4F5C_u4E3A_u65B9_u6CD5_u8C03_u7528"><a href="#u4F5C_u4E3A_u65B9_u6CD5_u8C03_u7528" class="headerlink" title="作为方法调用"></a>作为方法调用</h2><p>一个方法<strong>method</strong>是关联到一个对象上的属性函数。对于方法调用，<strong>this</strong>绑定调用的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name: <span class="string">'Albert Einstein'</span>,</span><br><span class="line">	age: <span class="number">66</span>,</span><br><span class="line">	greet: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.greet();</span><br></pre></td></tr></table></figure></p>
<p>在上例中，在调用<strong>greet</strong>时，<strong>this</strong>被绑定到<strong>person</strong>对象。对比一下两种方式：<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">title</span>&gt;</span>This test<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">		<span class="comment">//----------note begin ------------</span></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">testF</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">		<span class="built_in">console</span>.log(testF());</span><br><span class="line">		<span class="keyword">var</span> testFCopy = testF;</span><br><span class="line">		<span class="built_in">console</span>.log(testFCopy());</span><br><span class="line">		<span class="keyword">var</span> testObj = &#123;</span><br><span class="line">			testObjFunc: testF</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">console</span>.log(testObj.testObjFunc ());</span><br><span class="line">		<span class="comment">//---------note end---------------</span></span><br><span class="line">	</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>在Firebug中，可以看到如下输出：<br><img src="/img/1455793541898.png" alt="this指向"></p>
<p>前两次是作为函数调用，因此<strong>this</strong>参数指向全局环境（即<strong>Window</strong>）.<br>最后一次是作为方法调用，变量<strong>testObj</strong>是一个对象，有一个属性，名为<strong>testObjFunc</strong>，是指向<strong>testF()</strong>函数的引用。这样就创建了<strong>testObjFunc()</strong>方法。当调用这个方法时，<strong>this</strong>就会代表函数的上下文环境。</p>
<h2 id="u4F5C_u4E3A_u6784_u9020_u51FD_u6570_u8C03_u7528"><a href="#u4F5C_u4E3A_u6784_u9020_u51FD_u6570_u8C03_u7528" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h2><p>Constructor函数像其它函数一样声明，函数被当成构造函数使用时也没有什么不同。但调用的方式完全不同。</p>
<p>作为构造函数调用时，要在前面加上<strong>new</strong>关键字。这时，<strong>this</strong>被绑定到新的对象上。</p>
<p>JavaScript是原型继承语言。 对象可以直接从其他对象继承属性. 语言是无类的。函数被设计为通过<strong>new</strong>调用的被称为构造函数。通常，以PascalCase命名以容易区别于CamelCase. 在下面的例程中，注意<strong>greet</strong>函数使用<strong>this</strong>访问命名属性。<strong>this</strong>参数被绑定到<strong>Person</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> albert = <span class="keyword">new</span> Person(<span class="string">'Albert Einstein'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(albert.greet());</span><br></pre></td></tr></table></figure></p>
<h2 id="u4F7F_u7528apply_28_29_u548Ccall_28_29_u65B9_u6CD5"><a href="#u4F7F_u7528apply_28_29_u548Ccall_28_29_u65B9_u6CD5" class="headerlink" title="使用apply()和call()方法"></a>使用apply()和call()方法</h2><p>JavaScript的函数都是对象。与其他对象一样，函数也有固定的methods. 当使用函数的<strong>apply()</strong> method调用函数时, 需要传递两个参数给<strong>apply()</strong>: 作为函数上下文环境的对象和作为调用实参的值数组。<strong>call()</strong> method的使用方式类似，除了实参是直接以列表形式传递而不是作为数组。</p>
</div></article><div class="pagination"><a href="/2016/02/19/匿名函数/" class="pagination-prev">PREV</a><a href="/2016/02/06/testcode/" class="pagination-next">NEXT</a></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browserify/">Browserify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Callback/">Callback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Closure/">Closure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Table Layout in CSS/">Table Layout in CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Exam Analysis/">Exam Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/JQuery EasyUI Sourece Code Analysis/">JQuery EasyUI Sourece Code Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/AngularJS/">Angular</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/demystifying-javascript-closures-callbacks-iifes/">demystifying-javascript-closures-callbacks-iifes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Browserify/">Browserify</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/strict-mode/">strict mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/Try{} and Catch{}/">Try{} and Catch{}</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2016 <a href="/">Tilly Vally</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>