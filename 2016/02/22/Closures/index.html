<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Closures · Hexo of Tilly Vally @ GitHub</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">主页</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   博客</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li><li class="nav-list-item"><a href="https://github.com/xxxxx" target="_blank" class="nav-link">   github</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2016/02/22/Closures/" class="post-title-link">Closures</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Closure/" class="post-tag-link">Closure</a></li><li class="post-tag-item"><a href="/tags/JavaScript/" class="post-tag-link">JavaScript</a></li></ul><div class="post-time">星期五, 七月 15日 2016</div></div><div class="post-content"><h1 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h1><p>按传统来说，闭包closures一直是纯函数编程语言的一个特征。Javascript具有这类函数式编程语言的亲和关系<br>，将闭包考虑进语言的核心构造。闭包在主流库的通用性越来越高，因为使用闭包可以简化操作的复杂性。</p>
<p>首要的认识是，闭包在JavaScript随处可见。词法scope 本质上决定了在哪里和怎样对标识符进行声明，和如何在执行过程中进行查找。</p>
<p>简而言之，闭包是在函数被声明时被创建的一个scope ，函数可以访问并操作这个函数的外部变量. 换句话说，当函数本身被声明时，闭包允许函数访问所有在scope中的变量， 和其他函数一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="string">'I am outer'</span>; <span class="comment">//Define a value in global scope</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123; <span class="comment">//Declare a a function in global scope</span></span><br><span class="line">	<span class="built_in">console</span>.log(outer);</span><br><span class="line">&#125; </span><br><span class="line">outerFn(); <span class="comment">//prints - I am outer</span></span><br></pre></td></tr></table></figure></p>
<p>好像没有什么奇怪的地方，但这是闭包最普通的情况：变量和函数都在全局域中声明。在函数中，可以访问全局域（<strong>outer外部</strong>）中的变量。 因此本质上，函数<strong>outerFn()</strong>的外部域是一个闭包，对<strong>outerFn()</strong>总是可见的。下面是一个更复杂一些的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="string">'Outer'</span>; <span class="comment">//Variable declared in global scope</span></span><br><span class="line"><span class="keyword">var</span> copy;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>)</span>&#123; <span class="comment">//Function declared in global scope</span></span><br><span class="line">	<span class="keyword">var</span> inner = <span class="string">'Inner'</span>; <span class="comment">//Variable has function scope only, can not be</span></span><br><span class="line">	<span class="comment">//accessed from outside</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>)</span>&#123; <span class="comment">//Inner function within Outer function,</span></span><br><span class="line">		<span class="comment">//both global context and outer</span></span><br><span class="line">		<span class="comment">//context are available hence can access</span></span><br><span class="line">		<span class="comment">//'outer' and 'inner'</span></span><br><span class="line">		<span class="built_in">console</span>.log(outer);</span><br><span class="line">		<span class="built_in">console</span>.log(inner);</span><br><span class="line">	&#125;</span><br><span class="line">	copy=innerFn; <span class="comment">//Store reference to inner function,</span></span><br><span class="line">	<span class="comment">//because 'copy' itself is declared</span></span><br><span class="line">	<span class="comment">//in global context, it will be available</span></span><br><span class="line">	<span class="comment">//outside also</span></span><br><span class="line">&#125; </span><br><span class="line">outerFn();</span><br><span class="line">copy(); <span class="comment">//Cant invoke innerFn() directly but can invoke via a</span></span><br><span class="line"><span class="comment">//variable declared in global scope</span></span><br></pre></td></tr></table></figure></p>
<p>在<strong>innerFn()</strong>中, 变量<strong>outer</strong>由于是全局域的因此可以访问。 内部函数的执行是在外部函数已执行后：将内部函数的引用复制给一个全局域变量<strong>copy</strong>. 当<strong>innerFn()</strong>执行时，<strong>outerFn()</strong>函数的域已经消失了，当通过<strong>copy</strong>变量调用时是不可见的。那么，下面的代码会出错吗？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(inner);</span><br></pre></td></tr></table></figure></p>
<p>变量<strong>inner</strong>应该是<strong>undefined</strong>吗? 但是，前面代码的实际输出是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Outer"</span></span><br><span class="line"><span class="string">"Inner"</span></span><br></pre></td></tr></table></figure></p>
<p>为什么在执行<strong>innerFn()</strong>时，变量<strong>inner</strong>仍然可见，理论上函数的的作用域早已没有了？当在<strong>outerFn()</strong>中声明<strong>innerFn()</strong>时，不仅声明了函数定义，同时也形成了一个不仅包含函数声明，而且还包含有在函数声明的那一点的当时所有变量的闭包。当执行<strong>innerFn()</strong>时，即使声明它的作用域已经消失，它仍可通过闭包来访问原有的它被声明时的作用域.</p>
<p>进一步扩展上面的例子，看看闭包的能力：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer=<span class="string">'outer'</span>;</span><br><span class="line"><span class="keyword">var</span> copy;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> inner=<span class="string">'inner'</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params">param</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(outer);</span><br><span class="line">		<span class="built_in">console</span>.log(inner);</span><br><span class="line">		<span class="built_in">console</span>.log(param);</span><br><span class="line">		<span class="built_in">console</span>.log(magic);</span><br><span class="line">	&#125;</span><br><span class="line">	copy=innerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(magic); <span class="comment">//ERROR: magic not defined</span></span><br><span class="line"><span class="keyword">var</span> magic=<span class="string">"Magic"</span>;</span><br><span class="line">outerFn();</span><br><span class="line">copy(<span class="string">"copy"</span>);</span><br></pre></td></tr></table></figure></p>
<p>如上，首先给<strong>innerFn()</strong>增加了一个形参，以演示形参也是闭包的一部分。这里有两点很重要：</p>
<ul>
<li>所有外部域的变量都包含在闭包中，即使变量是在函数之后被声明。因此<strong>innerFn()</strong>函数中的<code>console.log(magic)</code>正常执行。</li>
<li>但全局域中同样的代码行<code>console.log(magic)</code>将会出错，因为在同一域中，未被定义的变量不能被引用。</li>
</ul>
<p>下面讨论一些闭包的常见使用场景。</p>
<h2 id="u8BA1_u65F6_u5668_u4E0E_u56DE_u8C03"><a href="#u8BA1_u65F6_u5668_u4E0E_u56DE_u8C03" class="headerlink" title="计时器与回调"></a>计时器与回调</h2><p>在实现计时器或回调函数时，多数情况下，需要在之后的某个时间点异步调用处理程序。因为是异步调用，需要从函数的外部域中访问变量，参考下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timerFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( message );</span><br><span class="line">	&#125;, <span class="number">1000</span> );</span><br><span class="line">&#125; </span><br><span class="line">delay( <span class="string">" Hello World"</span> );</span><br></pre></td></tr></table></figure></p>
<p><strong>timerFn()</strong>函数被传递给内置库函数<strong>setTimeout()</strong>. 但<strong>timerFn()</strong>函数有一个在函数<strong>delay()</strong>之上的作用域闭包，因此可以引用变量<strong>message</strong>.</p>
<h2 id="Private_variables"><a href="#Private_variables" class="headerlink" title="Private variables"></a>Private variables</h2><p>闭包常用于封装信息以作为私有变量。JavaScript不允许封装，但通过闭包可以实现同样的效果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> points=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">this</span>.getPoints=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> points;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">this</span>.score=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		points++;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> private = <span class="keyword">new</span> privateTest();</span><br><span class="line">private.score();</span><br><span class="line"><span class="built_in">console</span>.log(private.points); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(private.getPoints());</span><br></pre></td></tr></table></figure></p>
<p>上例中的函数被作为构造函数创建，在<strong>privateTest()</strong>函数中，变量<strong>var points=0</strong>作为函数域内的变量，只能在<strong>privateTest()</strong>函数内被访问. 此外，还创建了一个访问器（<strong> accessor</strong>）函数（也叫做<strong>getter</strong>）—<strong>getPoints()</strong>—这个方法可以从<strong>privateTest()</strong>函数外部读取变量<strong>points</strong>, 这样变量就是函数私有的。另一个方法<strong>score()</strong>, 可以从<strong>privateTest()</strong>函数外部改变变量<strong>points</strong>的值。这样就可以对私有变量进行控制。<br>这种模式在编写基于约定和预定义接口的变量访问库代码时非常有用。</p>
<h2 id="Loops_and_closures"><a href="#Loops_and_closures" class="headerlink" title="Loops and closures"></a>Loops and closures</h2><p>看一下下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个代码段会在终端里以100毫秒的间隔打印输出1, 2, 3, 4, and 5，对吗？实际上，代码会打印6, 6, 6, 6, and 6.这是闭包与循环经常会遇到的一个问题。变量<strong>i</strong>在函数域完结之后被更新。这意味着每个限定域的函数处理器<strong>handler</strong>总是会打印最后存储在<strong>i</strong>中的值。实际上，<strong>timeout</strong>回调函数是在循环完成后执行的。如果在循环中以这种方式调用函数，<strong>JSLint</strong>会警告这种常见问题。</p>
<p>怎么样解决呢？可以引入函数域并在其中copy一个<strong>i</strong>的变量，如下面的例子那样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">		setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log( j );</span><br><span class="line">		&#125;, j*<span class="number">100</span>);</span><br><span class="line">	&#125;)( i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在代码中，变量<strong>i</strong>的值被复制到IIFE的变量<strong>j</strong>，在每个循环轮次里，引入的IIFE创建了一个新域，从而以正确的值更新了当前的复本。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>模块用于模仿类，专注于变量和函数的公开和私有访问实现。模块有助于防止全局变量污染。有效地使用模块可以在大段代码情况下减少命名冲突 。模块的典型格式如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Var moduleName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//private state</span></span><br><span class="line">	<span class="comment">//private functions</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="comment">//public state</span></span><br><span class="line">		<span class="comment">//public variables</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种模式必须满足两个条件：</p>
<ul>
<li>必须有一个外部封闭函数，且保证被至少执行一次。</li>
<li>这个外部封闭函数必须返回至少一个内部函数。这对于在私有状态上生成闭包是必须的-不这样做，私有状态不能被访问。.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> secret = <span class="string">'supersecretkey'</span>;</span><br><span class="line">	<span class="keyword">var</span> passcode = <span class="string">'nuke'</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getSecret</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( secret );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getPassCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( passcode );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getSecret: getSecret,</span><br><span class="line">		getPassCode: getPassCode</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">superModule.getSecret();</span><br><span class="line">superModule.getPassCode();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的例子满足这两个条件。首先，创建了一个IIFE或命名函数以作为外部函数。其中定义的变量是私有的，因为它们在函数的作用域内。返回的公开函数确保在私有域上有闭包。在模块中使用IIFE实际会导致函数单次执行。如果要多次执行，创建命名的函数表达式作为模块的一部分就可以了。</p>
<h2 id="u683C_u5F0F_u4E0A_u7684_u8003_u8651"><a href="#u683C_u5F0F_u4E0A_u7684_u8003_u8651" class="headerlink" title="格式上的考虑"></a>格式上的考虑</h2><p>综上，可以总结出一些常见的模式（作为常见可行的指导原则而不是必须遵守的规则）：</p>
<ul>
<li><p>使用函数声明而不是函数表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>永远不要在一个非函数代码块中声明函数(if, while等等). 要将函数赋值给变量. 虽然浏览器允许在非函数代码块中声明函数，但解析方式是不一样的。</p>
</li>
<li>Never name a parameter <strong>arguments</strong>. This will take precedence over the <strong>arguments</strong> object that is given to every function scope</li>
</ul>
</div></article><div class="pagination"><a href="/2016/02/24/Patterns/" class="pagination-prev">PREV</a><a href="/2016/02/19/匿名函数/" class="pagination-next">NEXT</a></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Angular/">Angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Browserify/">Browserify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Callback/">Callback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Closure/">Closure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event/">Event</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Table Layout in CSS/">Table Layout in CSS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/14/Exam Analysis/">Exam Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/27/JQuery EasyUI Sourece Code Analysis/">JQuery EasyUI Sourece Code Analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/AngularJS/">Angular</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/23/demystifying-javascript-closures-callbacks-iifes/">demystifying-javascript-closures-callbacks-iifes</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/Browserify/">Browserify</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/strict-mode/">strict mode</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/26/Try{} and Catch{}/">Try{} and Catch{}</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2016 <a href="/">Tilly Vally</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>